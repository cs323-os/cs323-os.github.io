

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Lab 4: Preemptive Multitasking &mdash; CS 323, Fall 2022 1 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
  
  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="CS 323, Fall 2022 1 documentation" href="../index.html"/>
        <link rel="up" title="Lab" href="../lab.html"/>
        <link rel="next" title="Lab 5: File system, Spawn and Shell" href="lab5.html"/>
        <link rel="prev" title="Lab 3: User Environments" href="lab3.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../index.html" class="fa fa-home"> CS 323, Fall 2022</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../info.html">General Information</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../info.html#prerequisite">Prerequisite</a></li>
<li class="toctree-l2"><a class="reference internal" href="../info.html#meetings">Meetings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../info.html#grades">Grades</a></li>
<li class="toctree-l2"><a class="reference internal" href="../info.html#labs">Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../info.html#prep-questions">Prep Questions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../info.html#equipment-problems">Equipment Problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../info.html#other-policies">Other Policies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../info.html#text">Text</a></li>
<li class="toctree-l2"><a class="reference internal" href="../info.html#staff-ta">Staff/TA</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cal.html">Schedule</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../q.html">Preparation Questions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../refs.html">Reference Materials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../refs.html#c-programming">C Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../refs.html#unix">UNIX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../refs.html#x86-emulation">x86 Emulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../refs.html#x86-assembly-language">x86 Assembly Language</a></li>
<li class="toctree-l2"><a class="reference internal" href="../refs.html#pc-hardware-programming">PC Hardware Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../refs.html#reference-quizzes">Reference Quizzes</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../lab.html">Lab</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab1.html">Lab 1: Booting a PC</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab2.html">Lab 2: Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab3.html">Lab 3: User Environments</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Lab 4: Preemptive Multitasking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab5.html">Lab 5: File system, Spawn and Shell</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab6.html">Lab 6: Network Driver</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proj.html">Final Project</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proj.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proj.html#deliverables">Deliverables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proj.html#project-ideas-if-you-found-none">Project ideas (if you found none)</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">CS 323, Fall 2022</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../lab.html">Lab</a> &raquo;</li>
      
    <li>Lab 4: Preemptive Multitasking</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../_sources/lab/lab4.rst.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <section id="lab-4-preemptive-multitasking">
<h1>Lab 4: Preemptive Multitasking<a class="headerlink" href="#lab-4-preemptive-multitasking" title="Permalink to this heading">¶</a></h1>
<ul class="simple">
<li><p><strong>Handed out:</strong> Thursday, Oct 12, 2017</p></li>
<li><p><strong>Part A due:</strong> Friday, Oct 20, 2017</p></li>
<li><p><strong>Part B due:</strong> Friday, Oct 27, 2017</p></li>
<li><p><strong>Part C due:</strong> Friday, Nov 10, 2017</p></li>
</ul>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h2>
<p>In this lab you will implement preemptive multitasking among multiple
simultaneously active user-mode environments.</p>
<ul class="simple">
<li><p>In part A, you will add multiprocessor support to JOS, implement
round-robin scheduling, and add basic environment management system
calls (calls that create and destroy environments, and allocate/map
memory).</p></li>
<li><p>In part B, you will implement a Unix-like <code class="docutils literal notranslate"><span class="pre">fork()</span></code>, which allows a
user-mode environment to create copies of itself.</p></li>
<li><p>Finally, in part C you will add support for inter-process
communication (IPC), allowing different user-mode environments to
communicate and synchronize with each other explicitly. You will
also add support for hardware clock interrupts and preemption.</p></li>
</ul>
<section id="getting-started">
<h3>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this heading">¶</a></h3>
<p>Use Git to commit your Lab 3 source, fetch the latest version of the
course repository, and then create a local branch called <code class="docutils literal notranslate"><span class="pre">lab4</span></code> based
on our lab4 branch, <code class="docutils literal notranslate"><span class="pre">origin/lab4</span></code>:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ <span class="nb">cd</span> ~/cs3210/lab
$ add git
$ git pull
Already up-to-date.
$ git checkout -b lab4 origin/lab4
Branch lab4 <span class="nb">set</span> up to track remote branch refs/remotes/origin/lab4.
Switched to a new branch <span class="s2">&quot;lab4&quot;</span>
$ git merge lab3
Merge made by recursive.
...
$
</pre></div>
</div>
<p>Lab 4 contains a number of new source files, some of which you should
browse before you start:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">kern/cpu.h</span></code></p></td>
<td><p>Kernel-private definitions for multiprocessor
support</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">kern/mpconfig.c</span></code></p></td>
<td><p>Code to read the multiprocessor configuration</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">kern/lapic.c</span></code></p></td>
<td><p>Kernel code driving the local APIC unit in
each processor</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">kern/mpentry.S</span></code></p></td>
<td><p>Assembly-language entry code for non-boot CPUs</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">kern/spinlock.h</span></code></p></td>
<td><p>Kernel-private definitions for spin locks,
including the big kernel lock</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">kern/spinlock.c</span></code></p></td>
<td><p>Kernel code implementing spin locks</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">kern/sched.c</span></code></p></td>
<td><p>Code skeleton of the scheduler that you are
about to implement</p></td>
</tr>
</tbody>
</table>
</section>
<section id="lab-requirements">
<h3>Lab Requirements<a class="headerlink" href="#lab-requirements" title="Permalink to this heading">¶</a></h3>
<p>This lab is divided into three parts, A, B, and C. We have allocated one
week in the schedule for each part.</p>
<p>As before, you will need to do all of the regular exercises described in
the lab and <em>at least one</em> challenge problem. (You do not need to do one
challenge problem per part, just one for the whole lab.) Additionally,
you will need to write up a brief description of the challenge problem
that you implemented. If you implement more than one challenge problem,
you only need to describe one of them in the write-up, though of course
you are welcome to do more. Place the write-up in a file called
<code class="docutils literal notranslate"><span class="pre">answers-lab4.txt</span></code> in the top level of your <code class="docutils literal notranslate"><span class="pre">lab</span></code> directory before
handing in your work.</p>
</section>
</section>
<section id="part-a-multiprocessor-support-and-cooperative-multitasking">
<h2>Part A: Multiprocessor Support and Cooperative Multitasking<a class="headerlink" href="#part-a-multiprocessor-support-and-cooperative-multitasking" title="Permalink to this heading">¶</a></h2>
<p>In the first part of this lab, you will first extend JOS to run on a
multiprocessor system, and then implement some new JOS kernel system
calls to allow user-level environments to create additional new
environments. You will also implement <em>cooperative</em> round-robin
scheduling, allowing the kernel to switch from one environment to
another when the current environment voluntarily relinquishes the CPU
(or exits). Later in part C you will implement <em>preemptive</em> scheduling,
which allows the kernel to re-take control of the CPU from an
environment after a certain time has passed even if the environment does
not cooperate.</p>
<section id="multiprocessor-support">
<h3>Multiprocessor Support<a class="headerlink" href="#multiprocessor-support" title="Permalink to this heading">¶</a></h3>
<p>We are going to make JOS support “symmetric multiprocessing” (SMP), a
multiprocessor model in which all CPUs have equivalent access to system
resources such as memory and I/O buses. While all CPUs are functionally
identical in SMP, during the boot process they can be classified into
two types: the bootstrap processor (BSP) is responsible for initializing
the system and for booting the operating system; and the application
processors (APs) are activated by the BSP only after the operating
system is up and running. Which processor is the BSP is determined by
the hardware and the BIOS. Up to this point, all your existing JOS code
has been running on the BSP.</p>
<p>In an SMP system, each CPU has an accompanying local APIC (LAPIC) unit.
The LAPIC units are responsible for delivering interrupts throughout the
system. The LAPIC also provides its connected CPU with a unique
identifier. In this lab, we make use of the following basic
functionality of the LAPIC unit (in <code class="docutils literal notranslate"><span class="pre">kern/lapic.c</span></code>):</p>
<ul class="simple">
<li><p>Reading the LAPIC identifier (APIC ID) to tell which CPU our code is
currently running on (see <code class="docutils literal notranslate"><span class="pre">cpunum()</span></code>).</p></li>
<li><p>Sending the <code class="docutils literal notranslate"><span class="pre">STARTUP</span></code> interprocessor interrupt (IPI) from the BSP
to the APs to bring up other CPUs (see <code class="docutils literal notranslate"><span class="pre">lapic_startap()</span></code>).</p></li>
<li><p>In part C, we program LAPIC’s built-in timer to trigger clock
interrupts to support preemptive multitasking (see <code class="docutils literal notranslate"><span class="pre">apic_init()</span></code>).</p></li>
</ul>
<p>A processor accesses its LAPIC using memory-mapped I/O (MMIO). In MMIO,
a portion of <em>physical</em> memory is hardwired to the registers of some I/O
devices, so the same load/store instructions typically used to access
memory can be used to access device registers. You’ve already seen one
IO hole at physical address <code class="docutils literal notranslate"><span class="pre">0xA0000</span></code> (we use this to write to the VGA
display buffer). The LAPIC lives in a hole starting at physical address
<code class="docutils literal notranslate"><span class="pre">0xFE000000</span></code> (32MB short of 4GB), so it’s too high for us to access
using our usual direct map at <code class="docutils literal notranslate"><span class="pre">KERNBASE</span></code>. The JOS virtual memory map
leaves a 4MB gap at <code class="docutils literal notranslate"><span class="pre">MMIOBASE</span></code> so we have a place to map devices like
this. Since later labs introduce more MMIO regions, you’ll write a
simple function to allocate space from this region and map device memory
to it.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 1.</strong>
Implement <code class="docutils literal notranslate"><span class="pre">mmio_map_region()</span></code> in <code class="docutils literal notranslate"><span class="pre">kern/pmap.c</span></code>. To see how
this is used, look at the beginning of <code class="docutils literal notranslate"><span class="pre">lapic_init()</span></code> in
<code class="docutils literal notranslate"><span class="pre">kern/lapic.c</span></code>. You’ll have to do the next exercise, too, before the
tests for <code class="docutils literal notranslate"><span class="pre">mmio_map_region()</span></code> will run.</p>
</div>
</section>
</section>
<section id="application-processor-bootstrap">
<h2>Application Processor Bootstrap<a class="headerlink" href="#application-processor-bootstrap" title="Permalink to this heading">¶</a></h2>
<p>Before booting up APs, the BSP should first collect information about
the multiprocessor system, such as the total number of CPUs, their APIC
IDs and the MMIO address of the LAPIC unit. The <code class="docutils literal notranslate"><span class="pre">mp_init()</span></code> function
in <code class="docutils literal notranslate"><span class="pre">kern/mpconfig.c</span></code> retrieves this information by reading the MP
configuration table that resides in the BIOS’s region of memory.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">boot_aps()</span></code> function (in <code class="docutils literal notranslate"><span class="pre">kern/init.c</span></code>) drives the AP bootstrap
process. APs start in real mode, much like how the bootloader started in
<code class="docutils literal notranslate"><span class="pre">boot/boot.S</span></code>, so <code class="docutils literal notranslate"><span class="pre">boot_aps()</span></code> copies the AP entry code
(<code class="docutils literal notranslate"><span class="pre">kern/mpentry.S</span></code>) to a memory location that is addressable in the
real mode. Unlike with the bootloader, we have some control over where
the AP will start executing code; we copy the entry code to <code class="docutils literal notranslate"><span class="pre">0x7000</span></code>
(<code class="docutils literal notranslate"><span class="pre">MPENTRY_PADDR</span></code>), but any unused, page-aligned physical address below
640KB would work.</p>
<p>After that, <code class="docutils literal notranslate"><span class="pre">boot_aps()</span></code> activates APs one after another, by sending
<code class="docutils literal notranslate"><span class="pre">STARTUP</span></code> IPIs to the LAPIC unit of the corresponding AP, along with
an initial <code class="docutils literal notranslate"><span class="pre">CS:IP</span></code> address at which the AP should start running its
entry code (<code class="docutils literal notranslate"><span class="pre">MPENTRY_PADDR</span></code> in our case). The entry code in
<code class="docutils literal notranslate"><span class="pre">kern/mpentry.S</span></code> is quite similar to that of <code class="docutils literal notranslate"><span class="pre">boot/boot.S</span></code>. After
some brief setup, it puts the AP into protected mode with paging
enabled, and then calls the C setup routine <code class="docutils literal notranslate"><span class="pre">mp_main()</span></code> (also in
<code class="docutils literal notranslate"><span class="pre">kern/init.c</span></code>). <code class="docutils literal notranslate"><span class="pre">boot_aps()</span></code> waits for the AP to signal a
<code class="docutils literal notranslate"><span class="pre">CPU_STARTED</span></code> flag in <code class="docutils literal notranslate"><span class="pre">cpu_status</span></code> field of its <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">CpuInfo</span></code>
before going on to wake up the next one.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 2.</strong>
Read <code class="docutils literal notranslate"><span class="pre">boot_aps()</span></code> and <code class="docutils literal notranslate"><span class="pre">mp_main()</span></code> in <code class="docutils literal notranslate"><span class="pre">kern/init.c</span></code>,
and the assembly code in <code class="docutils literal notranslate"><span class="pre">kern/mpentry.S</span></code>. Make sure you understand
the control flow transfer during the bootstrap of APs. Then modify your
implementation of <code class="docutils literal notranslate"><span class="pre">page_init()</span></code> in <code class="docutils literal notranslate"><span class="pre">kern/pmap.c</span></code> to avoid adding the
page at <code class="docutils literal notranslate"><span class="pre">MPENTRY_PADDR</span></code> to the free list, so that we can safely copy
and run AP bootstrap code at that physical address. Your code should
pass the updated <code class="docutils literal notranslate"><span class="pre">check_page_free_list()</span></code> test (but might fail the
updated <code class="docutils literal notranslate"><span class="pre">check_kern_pgdir()</span></code> test, which we will fix soon).</p>
</div>
<div class="admonition-question admonition">
<p class="admonition-title">Question</p>
<p>1. Compare <code class="docutils literal notranslate"><span class="pre">kern/mpentry.S</span></code> side by side with <code class="docutils literal notranslate"><span class="pre">boot/boot.S</span></code>. Bearing
in mind that <code class="docutils literal notranslate"><span class="pre">kern/mpentry.S</span></code> is compiled and linked to run above
<code class="docutils literal notranslate"><span class="pre">KERNBASE</span></code> just like everything else in the kernel, what is the
purpose of macro <code class="docutils literal notranslate"><span class="pre">MPBOOTPHYS</span></code>? Why is it necessary in
<code class="docutils literal notranslate"><span class="pre">kern/mpentry.S</span></code> but not in <code class="docutils literal notranslate"><span class="pre">boot/boot.S</span></code>? In other words, what
could go wrong if it were omitted in <code class="docutils literal notranslate"><span class="pre">kern/mpentry.S</span></code>?
Hint: recall the differences between the link address and the load
address that we have discussed in Lab 1.</p>
</div>
</section>
<section id="per-cpu-state-and-initialization">
<h2>Per-CPU State and Initialization<a class="headerlink" href="#per-cpu-state-and-initialization" title="Permalink to this heading">¶</a></h2>
<p>When writing a multiprocessor OS, it is important to distinguish between
per-CPU state that is private to each processor, and global state that
the whole system shares. <code class="docutils literal notranslate"><span class="pre">kern/cpu.h</span></code> defines most of the per-CPU
state, including <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">CpuInfo</span></code>, which stores per-CPU variables.
<code class="docutils literal notranslate"><span class="pre">cpunum()</span></code> always returns the ID of the CPU that calls it, which can
be used as an index into arrays like <code class="docutils literal notranslate"><span class="pre">cpus</span></code>. Alternatively, the macro
<code class="docutils literal notranslate"><span class="pre">thiscpu</span></code> is shorthand for the current CPU’s <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">CpuInfo</span></code>.</p>
<p>Here is the per-CPU state you should be aware of:</p>
<ul>
<li><p><strong>Per-CPU kernel stack</strong>.
Because multiple CPUs can trap into the kernel simultaneously, we
need a separate kernel stack for each processor to prevent them from
interfering with each other’s execution. The array
<code class="docutils literal notranslate"><span class="pre">percpu_kstacks[NCPU][KSTKSIZE]</span></code> reserves space for NCPU’s worth of
kernel stacks.</p>
<p>In Lab 2, you mapped the physical memory that <code class="docutils literal notranslate"><span class="pre">bootstack</span></code> refers to
as the BSP’s kernel stack just below <code class="docutils literal notranslate"><span class="pre">KSTACKTOP</span></code>. Similarly, in
this lab, you will map each CPU’s kernel stack into this region with
guard pages acting as a buffer between them. CPU 0’s stack will still
grow down from <code class="docutils literal notranslate"><span class="pre">KSTACKTOP</span></code>; CPU 1’s stack will start <code class="docutils literal notranslate"><span class="pre">KSTKGAP</span></code>
bytes below the bottom of CPU 0’s stack, and so on.
<code class="docutils literal notranslate"><span class="pre">inc/memlayout.h</span></code> shows the mapping layout.</p>
</li>
<li><p><strong>Per-CPU TSS and TSS descriptor</strong>.
A per-CPU task state segment (TSS) is also needed in order to
specify where each CPU’s kernel stack lives. The TSS for CPU <em>i</em> is
stored in <code class="docutils literal notranslate"><span class="pre">cpus[i].cpu_ts</span></code>, and the corresponding TSS descriptor is
defined in the GDT entry <code class="docutils literal notranslate"><span class="pre">gdt[(GD_TSS0</span> <span class="pre">&gt;&gt;</span> <span class="pre">3)</span> <span class="pre">+</span> <span class="pre">i]</span></code>. The global
<code class="docutils literal notranslate"><span class="pre">ts</span></code> variable defined in <code class="docutils literal notranslate"><span class="pre">kern/trap.c</span></code> will no longer be useful.</p></li>
<li><p><strong>Per-CPU current environment pointer</strong>.
Since each CPU can run different user process simultaneously, we
redefined the symbol <code class="docutils literal notranslate"><span class="pre">curenv</span></code> to refer to
<code class="docutils literal notranslate"><span class="pre">cpus[cpunum()].cpu_env</span></code> (or <code class="docutils literal notranslate"><span class="pre">thiscpu-&gt;cpu_env</span></code>), which points to
the environment <em>currently</em> executing on the <em>current</em> CPU (the CPU
on which the code is running).</p></li>
<li><p><strong>Per-CPU system registers</strong>.
All registers, including system registers, are private to a CPU.
Therefore, instructions that initialize these registers, such as
<code class="docutils literal notranslate"><span class="pre">lcr3()</span></code>, <code class="docutils literal notranslate"><span class="pre">ltr()</span></code>, <code class="docutils literal notranslate"><span class="pre">lgdt()</span></code>, <code class="docutils literal notranslate"><span class="pre">lidt()</span></code>, etc., must be executed
once on each CPU. Functions <code class="docutils literal notranslate"><span class="pre">env_init_percpu()</span></code> and
<code class="docutils literal notranslate"><span class="pre">trap_init_percpu()</span></code> are defined for this purpose.</p></li>
</ul>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 3.</strong>
Modify <code class="docutils literal notranslate"><span class="pre">mem_init_mp()</span></code> (in <code class="docutils literal notranslate"><span class="pre">kern/pmap.c</span></code>) to map per-CPU
stacks starting at <code class="docutils literal notranslate"><span class="pre">KSTACKTOP</span></code>, as shown in <code class="docutils literal notranslate"><span class="pre">inc/memlayout.h</span></code>. The
size of each stack is <code class="docutils literal notranslate"><span class="pre">KSTKSIZE</span></code> bytes plus <code class="docutils literal notranslate"><span class="pre">KSTKGAP</span></code> bytes of
unmapped guard pages. Your code should pass the new check in
<code class="docutils literal notranslate"><span class="pre">check_kern_pgdir()</span></code>.</p>
</div>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 4.</strong>
The code in <code class="docutils literal notranslate"><span class="pre">trap_init_percpu()</span></code> (<code class="docutils literal notranslate"><span class="pre">kern/trap.c</span></code>)
initializes the TSS and TSS descriptor for the BSP. It worked in Lab 3,
but is incorrect when running on other CPUs. Change the code so that it
can work on all CPUs. (Note: your new code should not use the global
<code class="docutils literal notranslate"><span class="pre">ts</span></code> variable any more.)</p>
</div>
<p>When you finish the above exercises, run JOS in QEMU with 4 CPUs using
<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">qemu</span> <span class="pre">CPUS=4</span></code> (or <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">qemu-nox</span> <span class="pre">CPUS=4</span></code>), you should see output like
this:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>...
Physical memory: 66556K available, <span class="nv">base</span> <span class="o">=</span> 640K, <span class="nv">extended</span> <span class="o">=</span> 65532K
check_page_alloc<span class="o">()</span> succeeded!
check_page<span class="o">()</span> succeeded!
check_kern_pgdir<span class="o">()</span> succeeded!
check_page_installed_pgdir<span class="o">()</span> succeeded!
SMP: CPU <span class="m">0</span> found <span class="m">4</span> CPU<span class="o">(</span>s<span class="o">)</span>
enabled interrupts: <span class="m">1</span> <span class="m">2</span>
SMP: CPU <span class="m">1</span> starting
SMP: CPU <span class="m">2</span> starting
SMP: CPU <span class="m">3</span> starting
</pre></div>
</div>
</section>
<section id="locking">
<h2>Locking<a class="headerlink" href="#locking" title="Permalink to this heading">¶</a></h2>
<p>Our current code spins after initializing the AP in <code class="docutils literal notranslate"><span class="pre">mp_main()</span></code>.
Before letting the AP get any further, we need to first address race
conditions when multiple CPUs run kernel code simultaneously. The
simplest way to achieve this is to use a <em>big kernel lock</em>. The big
kernel lock is a single global lock that is held whenever an environment
enters kernel mode, and is released when the environment returns to user
mode. In this model, environments in user mode can run concurrently on
any available CPUs, but no more than one environment can run in kernel
mode; any other environments that try to enter kernel mode are forced to
wait.</p>
<p><code class="docutils literal notranslate"><span class="pre">kern/spinlock.h</span></code> declares the big kernel lock, namely
<code class="docutils literal notranslate"><span class="pre">kernel_lock</span></code>. It also provides <code class="docutils literal notranslate"><span class="pre">lock_kernel()</span></code> and
<code class="docutils literal notranslate"><span class="pre">unlock_kernel()</span></code>, shortcuts to acquire and release the lock. You
should apply the big kernel lock at four locations:</p>
<ul class="simple">
<li><p>In <code class="docutils literal notranslate"><span class="pre">i386_init()</span></code>, acquire the lock before the BSP wakes up the
other CPUs.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">mp_main()</span></code>, acquire the lock after initializing the AP, and
then call <code class="docutils literal notranslate"><span class="pre">sched_yield()</span></code> to start running environments on this AP.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">trap()</span></code>, acquire the lock when trapped from user mode. To
determine whether a trap happened in user mode or in kernel mode,
check the low bits of the <code class="docutils literal notranslate"><span class="pre">tf_cs</span></code>.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">env_run()</span></code>, release the lock <em>right before</em> switching to user
mode. Do not do that too early or too late, otherwise you will
experience races or deadlocks.</p></li>
</ul>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 5.</strong>
Apply the big kernel lock as described above, by calling
<code class="docutils literal notranslate"><span class="pre">lock_kernel()</span></code> and <code class="docutils literal notranslate"><span class="pre">unlock_kernel()</span></code> at the proper locations.</p>
</div>
<p>How to test if your locking is correct? You can’t at this moment! But
you will be able to after you implement the scheduler in the next
exercise.</p>
<div class="admonition-question admonition">
<p class="admonition-title">Question</p>
<p>2. It seems that using the big kernel lock guarantees that only one CPU
can run the kernel code at a time. Why do we still need separate
kernel stacks for each CPU? Describe a scenario in which using a
shared kernel stack will go wrong, even with the protection of the
big kernel lock.</p>
</div>
<div class="admonition-challenge admonition">
<p class="admonition-title">Challenge</p>
<p><strong>Challenge!</strong>
The big kernel lock is simple and easy to use. Nevertheless,
it eliminates all concurrency in kernel mode. Most modern operating
systems use different locks to protect different parts of their shared
state, an approach called <em>fine-grained locking</em>. Fine-grained locking
can increase performance significantly, but is more difficult to
implement and error-prone. If you are brave enough, drop the big kernel
lock and embrace concurrency in JOS!</p>
<p>It is up to you to decide the locking granularity (the amount of data
that a lock protects). As a hint, you may consider using spin locks to
ensure exclusive access to these shared components in the JOS kernel:
1) The page allocator; 2) The console driver; 3) The scheduler; 4)
The inter-process communication (IPC) state that you will implement
in the part C.</p>
</div>
<section id="round-robin-scheduling">
<h3>Round-Robin Scheduling<a class="headerlink" href="#round-robin-scheduling" title="Permalink to this heading">¶</a></h3>
<p>Your next task in this lab is to change the JOS kernel so that it can
alternate between multiple environments in “round-robin” fashion.
Round-robin scheduling in JOS works as follows:</p>
<ul class="simple">
<li><p>The function <code class="docutils literal notranslate"><span class="pre">sched_yield()</span></code> in the new <code class="docutils literal notranslate"><span class="pre">kern/sched.c</span></code> is
responsible for selecting a new environment to run. It searches
sequentially through the <code class="docutils literal notranslate"><span class="pre">envs[]</span></code> array in circular fashion,
starting just after the previously running environment (or at the
beginning of the array if there was no previously running
environment), picks the first environment it finds with a status of
<code class="docutils literal notranslate"><span class="pre">ENV_RUNNABLE</span></code> (see <code class="docutils literal notranslate"><span class="pre">inc/env.h</span></code>), and calls <code class="docutils literal notranslate"><span class="pre">env_run()</span></code> to jump
into that environment.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sched_yield()</span></code> must never run the same environment on two CPUs at
the same time. It can tell that an environment is currently running
on some CPU (possibly the current CPU) because that environment’s
status will be <code class="docutils literal notranslate"><span class="pre">ENV_RUNNING</span></code>.</p></li>
<li><p>We have implemented a new system call for you, <code class="docutils literal notranslate"><span class="pre">sys_yield()</span></code>, which
user environments can call to invoke the kernel’s <code class="docutils literal notranslate"><span class="pre">sched_yield()</span></code>
function and thereby voluntarily give up the CPU to a different
environment.</p></li>
</ul>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 6.</strong>
Implement round-robin scheduling in <code class="docutils literal notranslate"><span class="pre">sched_yield()</span></code> as
described above. Don’t forget to modify <code class="docutils literal notranslate"><span class="pre">syscall()</span></code> to dispatch
<code class="docutils literal notranslate"><span class="pre">sys_yield()</span></code>.</p>
<p>Make sure to invoke <code class="docutils literal notranslate"><span class="pre">sched_yield()</span></code> in <code class="docutils literal notranslate"><span class="pre">mp_main</span></code>.</p>
<p>Modify <code class="docutils literal notranslate"><span class="pre">kern/init.c</span></code> to create three (or more!) environments that all
run the program <code class="docutils literal notranslate"><span class="pre">user/yield.c</span></code>.</p>
<p>Run make qemu. You should see the environments switch back and forth
between each other five times before terminating, like below.</p>
<p>Test also with several CPUS: make qemu CPUS=2.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="n">Hello</span><span class="p">,</span> <span class="n">I</span> <span class="n">am</span> <span class="n">environment</span> <span class="mf">00001000.</span>
<span class="n">Hello</span><span class="p">,</span> <span class="n">I</span> <span class="n">am</span> <span class="n">environment</span> <span class="mf">00001001.</span>
<span class="n">Hello</span><span class="p">,</span> <span class="n">I</span> <span class="n">am</span> <span class="n">environment</span> <span class="mf">00001002.</span>
<span class="n">Back</span> <span class="ow">in</span> <span class="n">environment</span> <span class="mi">00001000</span><span class="p">,</span> <span class="n">iteration</span> <span class="mf">0.</span>
<span class="n">Back</span> <span class="ow">in</span> <span class="n">environment</span> <span class="mi">00001001</span><span class="p">,</span> <span class="n">iteration</span> <span class="mf">0.</span>
<span class="n">Back</span> <span class="ow">in</span> <span class="n">environment</span> <span class="mi">00001002</span><span class="p">,</span> <span class="n">iteration</span> <span class="mf">0.</span>
<span class="n">Back</span> <span class="ow">in</span> <span class="n">environment</span> <span class="mi">00001000</span><span class="p">,</span> <span class="n">iteration</span> <span class="mf">1.</span>
<span class="n">Back</span> <span class="ow">in</span> <span class="n">environment</span> <span class="mi">00001001</span><span class="p">,</span> <span class="n">iteration</span> <span class="mf">1.</span>
<span class="n">Back</span> <span class="ow">in</span> <span class="n">environment</span> <span class="mi">00001002</span><span class="p">,</span> <span class="n">iteration</span> <span class="mf">1.</span>
<span class="o">...</span>
</pre></div>
</div>
<p>After the <code class="docutils literal notranslate"><span class="pre">yield</span></code> programs exit, there will be no runnable environment
in the system, the scheduler should invoke the JOS kernel monitor. If
any of this does not happen, then fix your code before proceeding.</p>
<p>If you use CPUS=1 at this point, all environments should successfully
run. Setting CPUS larger than 1 at this time may result in a general
protection or kernel page fault once there are no more runnable
environments due to unhandled timer interrupts (which we will fix
below!).</p>
</div>
<div class="admonition-question admonition">
<p class="admonition-title">Question</p>
<p>3. In your implementation of <code class="docutils literal notranslate"><span class="pre">env_run()</span></code> you should have called
<code class="docutils literal notranslate"><span class="pre">lcr3()</span></code>. Before and after the call to <code class="docutils literal notranslate"><span class="pre">lcr3()</span></code>, your code makes
references (at least it should) to the variable <code class="docutils literal notranslate"><span class="pre">e</span></code>, the argument
to <code class="docutils literal notranslate"><span class="pre">env_run</span></code>. Upon loading the <code class="docutils literal notranslate"><span class="pre">%cr3</span></code> register, the addressing
context used by the MMU is instantly changed. But a virtual address
(namely <code class="docutils literal notranslate"><span class="pre">e</span></code>) has meaning relative to a given address context–the
address context specifies the physical address to which the virtual
address maps. Why can the pointer <code class="docutils literal notranslate"><span class="pre">e</span></code> be dereferenced both before
and after the addressing switch?</p>
<p>4. Whenever the kernel switches from one environment to another, it must
ensure the old environment’s registers are saved so they can be
restored properly later. Why? Where does this happen?</p>
</div>
<div class="admonition-challenge admonition">
<p class="admonition-title">Challenge</p>
<p><strong>Challenge!</strong>
Add a less trivial scheduling policy to the kernel, such as a
fixed-priority scheduler that allows each environment to be assigned a
priority and ensures that higher-priority environments are always chosen
in preference to lower-priority environments. If you’re feeling really
adventurous, try implementing a Unix-style adjustable-priority scheduler
or even a lottery or stride scheduler. (Look up “lottery scheduling” and
“stride scheduling” in Google.)</p>
<p>Write a test program or two that verifies that your scheduling algorithm
is working correctly (i.e., the right environments get run in the right
order). It may be easier to write these test programs once you have
implemented <code class="docutils literal notranslate"><span class="pre">fork()</span></code> and IPC in parts B and C of this lab.</p>
</div>
<div class="admonition-challenge admonition">
<p class="admonition-title">Challenge</p>
<p><strong>Challenge!</strong>
The JOS kernel currently does not allow applications to use
the x86 processor’s x87 floating-point unit (FPU), MMX instructions, or
Streaming SIMD Extensions (SSE). Extend the <code class="docutils literal notranslate"><span class="pre">Env</span></code> structure to provide
a save area for the processor’s floating point state, and extend the
context switching code to save and restore this state properly when
switching from one environment to another. The <code class="docutils literal notranslate"><span class="pre">FXSAVE</span></code> and
<code class="docutils literal notranslate"><span class="pre">FXRSTOR</span></code> instructions may be useful, but note that these are not in
the old i386 user’s manual because they were introduced in more recent
processors. Write a user-level test program that does something cool
with floating-point.</p>
</div>
</section>
<section id="system-calls-for-environment-creation">
<h3>System Calls for Environment Creation<a class="headerlink" href="#system-calls-for-environment-creation" title="Permalink to this heading">¶</a></h3>
<p>Although your kernel is now capable of running and switching between
multiple user-level environments, it is still limited to running
environments that the <em>kernel</em> initially set up. You will now implement
the necessary JOS system calls to allow <em>user</em> environments to create
and start other new user environments.</p>
<p>Unix provides the <code class="docutils literal notranslate"><span class="pre">fork()</span></code> system call as its process creation
primitive. Unix <code class="docutils literal notranslate"><span class="pre">fork()</span></code> copies the entire address space of calling
process (the parent) to create a new process (the child). The only
differences between the two observable from user space are their process
IDs and parent process IDs (as returned by <code class="docutils literal notranslate"><span class="pre">getpid</span></code> and <code class="docutils literal notranslate"><span class="pre">getppid</span></code>).
In the parent, <code class="docutils literal notranslate"><span class="pre">fork()</span></code> returns the child’s process ID, while in the
child, <code class="docutils literal notranslate"><span class="pre">fork()</span></code> returns 0. By default, each process gets its own
private address space, and neither process’s modifications to memory are
visible to the other.</p>
<p>You will provide a different, more primitive set of JOS system calls for
creating new user-mode environments. With these system calls you will be
able to implement a Unix-like <code class="docutils literal notranslate"><span class="pre">fork()</span></code> entirely in user space, in
addition to other styles of environment creation. The new system calls
you will write for JOS are as follows:</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sys_exofork</span></code>:</dt><dd><p>This system call creates a new environment with an almost blank
slate: nothing is mapped in the user portion of its address space,
and it is not runnable. The new environment will have the same
register state as the parent environment at the time of the
<code class="docutils literal notranslate"><span class="pre">sys_exofork</span></code> call. In the parent, <code class="docutils literal notranslate"><span class="pre">sys_exofork</span></code> will return the
<code class="docutils literal notranslate"><span class="pre">envid_t</span></code> of the newly created environment (or a negative error
code if the environment allocation failed). In the child, however,
it will return 0. (Since the child starts out marked as not
runnable, <code class="docutils literal notranslate"><span class="pre">sys_exofork</span></code> will not actually return in the child
until the parent has explicitly allowed this by marking the child
runnable using….)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sys_env_set_status</span></code>:</dt><dd><p>Sets the status of a specified environment to <code class="docutils literal notranslate"><span class="pre">ENV_RUNNABLE</span></code> or
<code class="docutils literal notranslate"><span class="pre">ENV_NOT_RUNNABLE</span></code>. This system call is typically used to mark a
new environment ready to run, once its address space and register
state has been fully initialized.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sys_page_alloc</span></code>:</dt><dd><p>Allocates a page of physical memory and maps it at a given virtual
address in a given environment’s address space.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sys_page_map</span></code>:</dt><dd><p>Copy a page mapping (<em>not</em> the contents of a page!) from one
environment’s address space to another, leaving a memory sharing
arrangement in place so that the new and the old mappings both refer
to the same page of physical memory.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sys_page_unmap</span></code>:</dt><dd><p>Unmap a page mapped at a given virtual address in a given
environment.</p>
</dd>
</dl>
</li>
</ul>
<p>For all of the system calls above that accept environment IDs, the JOS
kernel supports the convention that a value of 0 means “the current
environment.” This convention is implemented by <code class="docutils literal notranslate"><span class="pre">envid2env()</span></code> in
<code class="docutils literal notranslate"><span class="pre">kern/env.c</span></code>.</p>
<p>We have provided a very primitive implementation of a Unix-like
<code class="docutils literal notranslate"><span class="pre">fork()</span></code> in the test program <code class="docutils literal notranslate"><span class="pre">user/dumbfork.c</span></code>. This test program
uses the above system calls to create and run a child environment with a
copy of its own address space. The two environments then switch back and
forth using <code class="docutils literal notranslate"><span class="pre">sys_yield</span></code> as in the previous exercise. The parent exits
after 10 iterations, whereas the child exits after 20.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 7.</strong>
Implement the system calls described above in
<code class="docutils literal notranslate"><span class="pre">kern/syscall.c</span></code>. You will need to use various functions in
<code class="docutils literal notranslate"><span class="pre">kern/pmap.c</span></code> and <code class="docutils literal notranslate"><span class="pre">kern/env.c</span></code>, particularly <code class="docutils literal notranslate"><span class="pre">envid2env()</span></code>. For
now, whenever you call <code class="docutils literal notranslate"><span class="pre">envid2env()</span></code>, pass 1 in the <code class="docutils literal notranslate"><span class="pre">checkperm</span></code>
parameter. Be sure you check for any invalid system call arguments,
returning <code class="docutils literal notranslate"><span class="pre">-E_INVAL</span></code> in that case. Test your JOS kernel with
<code class="docutils literal notranslate"><span class="pre">user/dumbfork</span></code> and make sure it works before proceeding.</p>
</div>
<div class="admonition-challenge admonition">
<p class="admonition-title">Challenge</p>
<p><strong>Challenge!</strong>
Add the additional system calls necessary to <em>read</em> all of
the vital state of an existing environment as well as set it up. Then
implement a user mode program that forks off a child environment, runs
it for a while (e.g., a few iterations of <code class="docutils literal notranslate"><span class="pre">sys_yield()</span></code>), then takes a
complete snapshot or <em>checkpoint</em> of the child environment, runs the
child for a while longer, and finally restores the child environment to
the state it was in at the checkpoint and continues it from there. Thus,
you are effectively “replaying” the execution of the child environment
from an intermediate state. Make the child environment perform some
interaction with the user using <code class="docutils literal notranslate"><span class="pre">sys_cgetc()</span></code> or <code class="docutils literal notranslate"><span class="pre">readline()</span></code> so
that the user can view and mutate its internal state, and verify that
with your checkpoint/restart you can give the child environment a case
of selective amnesia, making it “forget” everything that happened beyond
a certain point.</p>
</div>
<p>This completes Part A of the lab; check it using make grade and hand it
in by commiting, tagging, and pushing to GitHub as usual. If you are trying to figure out why a
particular test case is failing, run <code class="docutils literal notranslate"><span class="pre">./grade-lab4</span> <span class="pre">-v</span></code>, which will show
you the output of the kernel builds and QEMU runs for each test, until a
test fails. When a test fails, the script will stop, and then you can
inspect <code class="docutils literal notranslate"><span class="pre">jos.out</span></code> to see what the kernel actually printed.</p>
</section>
</section>
<section id="part-b-copy-on-write-fork">
<h2>Part B: Copy-on-Write Fork<a class="headerlink" href="#part-b-copy-on-write-fork" title="Permalink to this heading">¶</a></h2>
<p>As mentioned earlier, Unix provides the <code class="docutils literal notranslate"><span class="pre">fork()</span></code> system call as its
primary process creation primitive. The <code class="docutils literal notranslate"><span class="pre">fork()</span></code> system call copies
the address space of the calling process (the parent) to create a new
process (the child).</p>
<p>xv6 Unix implements <code class="docutils literal notranslate"><span class="pre">fork()</span></code> by copying all data from the parent’s
pages into new pages allocated for the child. This is essentially the
same approach that <code class="docutils literal notranslate"><span class="pre">dumbfork()</span></code> takes. The copying of the parent’s
address space into the child is the most expensive part of the
<code class="docutils literal notranslate"><span class="pre">fork()</span></code> operation.</p>
<p>However, a call to <code class="docutils literal notranslate"><span class="pre">fork()</span></code> is frequently followed almost immediately
by a call to <code class="docutils literal notranslate"><span class="pre">exec()</span></code> in the child process, which replaces the child’s
memory with a new program. This is what the the shell typically does,
for example. In this case, the time spent copying the parent’s address
space is largely wasted, because the child process will use very little
of its memory before calling <code class="docutils literal notranslate"><span class="pre">exec()</span></code>.</p>
<p>For this reason, later versions of Unix took advantage of virtual memory
hardware to allow the parent and child to <em>share</em> the memory mapped into
their respective address spaces until one of the processes actually
modifies it. This technique is known as <em>copy-on-write</em>. To do this, on
<code class="docutils literal notranslate"><span class="pre">fork()</span></code> the kernel would copy the address space <em>mappings</em> from the
parent to the child instead of the contents of the mapped pages, and at
the same time mark the now-shared pages read-only. When one of the two
processes tries to write to one of these shared pages, the process takes
a page fault. At this point, the Unix kernel realizes that the page was
really a “virtual” or “copy-on-write” copy, and so it makes a new,
private, writable copy of the page for the faulting process. In this
way, the contents of individual pages aren’t actually copied until they
are actually written to. This optimization makes a <code class="docutils literal notranslate"><span class="pre">fork()</span></code> followed
by an <code class="docutils literal notranslate"><span class="pre">exec()</span></code> in the child much cheaper: the child will probably only
need to copy one page (the current page of its stack) before it calls
<code class="docutils literal notranslate"><span class="pre">exec()</span></code>.</p>
<p>In the next piece of this lab, you will implement a “proper” Unix-like
<code class="docutils literal notranslate"><span class="pre">fork()</span></code> with copy-on-write, as a user space library routine.
Implementing <code class="docutils literal notranslate"><span class="pre">fork()</span></code> and copy-on-write support in user space has the
benefit that the kernel remains much simpler and thus more likely to be
correct. It also lets individual user-mode programs define their own
semantics for <code class="docutils literal notranslate"><span class="pre">fork()</span></code>. A program that wants a slightly different
implementation (for example, the expensive always-copy version like
<code class="docutils literal notranslate"><span class="pre">dumbfork()</span></code>, or one in which the parent and child actually share
memory afterward) can easily provide its own.</p>
<section id="user-level-page-fault-handling">
<h3>User-level page fault handling<a class="headerlink" href="#user-level-page-fault-handling" title="Permalink to this heading">¶</a></h3>
<p>A user-level copy-on-write <code class="docutils literal notranslate"><span class="pre">fork()</span></code> needs to know about page faults on
write-protected pages, so that’s what you’ll implement first.
Copy-on-write is only one of many possible uses for user-level page
fault handling.</p>
<p>It’s common to set up an address space so that page faults indicate when
some action needs to take place. For example, most Unix kernels
initially map only a single page in a new process’s stack region, and
allocate and map additional stack pages later “on demand” as the
process’s stack consumption increases and causes page faults on stack
addresses that are not yet mapped. A typical Unix kernel must keep track
of what action to take when a page fault occurs in each region of a
process’s space. For example, a fault in the stack region will typically
allocate and map new page of physical memory. A fault in the program’s
BSS region will typically allocate a new page, fill it with zeroes, and
map it. In systems with demand-paged executables, a fault in the text
region will read the corresponding page of the binary off of disk and
then map it.</p>
<p>This is a lot of information for the kernel to keep track of. Instead of
taking the traditional Unix approach, you will decide what to do about
each page fault in user space, where bugs are less damaging. This design
has the added benefit of allowing programs great flexibility in defining
their memory regions; you’ll use user-level page fault handling later
for mapping and accessing files on a disk-based file system.</p>
</section>
</section>
<section id="setting-the-page-fault-handler">
<h2>Setting the Page Fault Handler<a class="headerlink" href="#setting-the-page-fault-handler" title="Permalink to this heading">¶</a></h2>
<p>In order to handle its own page faults, a user environment will need to
register a <em>page fault handler entrypoint</em> with the JOS kernel. The user
environment registers its page fault entrypoint via the new
<code class="docutils literal notranslate"><span class="pre">sys_env_set_pgfault_upcall</span></code> system call. We have added a new member
to the <code class="docutils literal notranslate"><span class="pre">Env</span></code> structure, <code class="docutils literal notranslate"><span class="pre">env_pgfault_upcall</span></code>, to record this
information.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 8.</strong>
Implement the <code class="docutils literal notranslate"><span class="pre">sys_env_set_pgfault_upcall</span></code> system call. Be
sure to enable permission checking when looking up the environment ID of
the target environment, since this is a “dangerous” system call.</p>
</div>
</section>
<section id="normal-and-exception-stacks-in-user-environments">
<h2>Normal and Exception Stacks in User Environments<a class="headerlink" href="#normal-and-exception-stacks-in-user-environments" title="Permalink to this heading">¶</a></h2>
<p>During normal execution, a user environment in JOS will run on the
<em>normal</em> user stack: its <code class="docutils literal notranslate"><span class="pre">ESP</span></code> register starts out pointing at
<code class="docutils literal notranslate"><span class="pre">USTACKTOP</span></code>, and the stack data it pushes resides on the page between
<code class="docutils literal notranslate"><span class="pre">USTACKTOP-PGSIZE</span></code> and <code class="docutils literal notranslate"><span class="pre">USTACKTOP-1</span></code> inclusive. When a page fault
occurs in user mode, however, the kernel will restart the user
environment running a designated user-level page fault handler on a
different stack, namely the <em>user exception</em> stack. In essence, we will
make the JOS kernel implement automatic “stack switching” on behalf of
the user environment, in much the same way that the x86 <em>processor</em>
already implements stack switching on behalf of JOS when transferring
from user mode to kernel mode!</p>
<p>The JOS user exception stack is also one page in size, and its top is
defined to be at virtual address <code class="docutils literal notranslate"><span class="pre">UXSTACKTOP</span></code>, so the valid bytes of
the user exception stack are from <code class="docutils literal notranslate"><span class="pre">UXSTACKTOP-PGSIZE</span></code> through
<code class="docutils literal notranslate"><span class="pre">UXSTACKTOP-1</span></code> inclusive. While running on this exception stack, the
user-level page fault handler can use JOS’s regular system calls to map
new pages or adjust mappings so as to fix whatever problem originally
caused the page fault. Then the user-level page fault handler returns,
via an assembly language stub, to the faulting code on the original
stack.</p>
<p>Each user environment that wants to support user-level page fault
handling will need to allocate memory for its own exception stack, using
the <code class="docutils literal notranslate"><span class="pre">sys_page_alloc()</span></code> system call introduced in part A.</p>
</section>
<section id="invoking-the-user-page-fault-handler">
<h2>Invoking the User Page Fault Handler<a class="headerlink" href="#invoking-the-user-page-fault-handler" title="Permalink to this heading">¶</a></h2>
<p>You will now need to change the page fault handling code in
<code class="docutils literal notranslate"><span class="pre">kern/trap.c</span></code> to handle page faults from user mode as follows. We will
call the state of the user environment at the time of the fault the
<em>trap-time</em> state.</p>
<p>If there is no page fault handler registered, the JOS kernel destroys
the user environment with a message as before. Otherwise, the kernel
sets up a trap frame on the exception stack that looks like a
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">UTrapframe</span></code> from <code class="docutils literal notranslate"><span class="pre">inc/trap.h</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                    <span class="o">&lt;--</span> <span class="n">UXSTACKTOP</span>
<span class="n">trap</span><span class="o">-</span><span class="n">time</span> <span class="n">esp</span>
<span class="n">trap</span><span class="o">-</span><span class="n">time</span> <span class="n">eflags</span>
<span class="n">trap</span><span class="o">-</span><span class="n">time</span> <span class="n">eip</span>
<span class="n">trap</span><span class="o">-</span><span class="n">time</span> <span class="n">eax</span>       <span class="n">start</span> <span class="n">of</span> <span class="n">struct</span> <span class="n">PushRegs</span>
<span class="n">trap</span><span class="o">-</span><span class="n">time</span> <span class="n">ecx</span>
<span class="n">trap</span><span class="o">-</span><span class="n">time</span> <span class="n">edx</span>
<span class="n">trap</span><span class="o">-</span><span class="n">time</span> <span class="n">ebx</span>
<span class="n">trap</span><span class="o">-</span><span class="n">time</span> <span class="n">esp</span>
<span class="n">trap</span><span class="o">-</span><span class="n">time</span> <span class="n">ebp</span>
<span class="n">trap</span><span class="o">-</span><span class="n">time</span> <span class="n">esi</span>
<span class="n">trap</span><span class="o">-</span><span class="n">time</span> <span class="n">edi</span>       <span class="n">end</span> <span class="n">of</span> <span class="n">struct</span> <span class="n">PushRegs</span>
<span class="n">tf_err</span> <span class="p">(</span><span class="n">error</span> <span class="n">code</span><span class="p">)</span>
<span class="n">fault_va</span>            <span class="o">&lt;--</span> <span class="o">%</span><span class="n">esp</span> <span class="n">when</span> <span class="n">handler</span> <span class="ow">is</span> <span class="n">run</span>
</pre></div>
</div>
<p>The kernel then arranges for the user environment to resume execution
with the page fault handler running on the exception stack with this
stack frame; you must figure out how to make this happen. The
<code class="docutils literal notranslate"><span class="pre">fault_va</span></code> is the virtual address that caused the page fault.</p>
<p>If the user environment is <em>already</em> running on the user exception stack
when an exception occurs, then the page fault handler itself has
faulted. In this case, you should start the new stack frame just under
the current <code class="docutils literal notranslate"><span class="pre">tf-&gt;tf_esp</span></code> rather than at <code class="docutils literal notranslate"><span class="pre">UXSTACKTOP</span></code>. You should
first push an empty 32-bit word, then a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">UTrapframe</span></code>.</p>
<p>To test whether <code class="docutils literal notranslate"><span class="pre">tf-&gt;tf_esp</span></code> is already on the user exception stack,
check whether it is in the range between <code class="docutils literal notranslate"><span class="pre">UXSTACKTOP-PGSIZE</span></code> and
<code class="docutils literal notranslate"><span class="pre">UXSTACKTOP-1</span></code>, inclusive.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 9.</strong>
Implement the code in <code class="docutils literal notranslate"><span class="pre">page_fault_handler</span></code> in
<code class="docutils literal notranslate"><span class="pre">kern/trap.c</span></code> required to dispatch page faults to the user-mode
handler. Be sure to take appropriate precautions when writing into the
exception stack. (What happens if the user environment runs out of space
on the exception stack?)</p>
</div>
</section>
<section id="user-mode-page-fault-entrypoint">
<h2>User-mode Page Fault Entrypoint<a class="headerlink" href="#user-mode-page-fault-entrypoint" title="Permalink to this heading">¶</a></h2>
<p>Next, you need to implement the assembly routine that will take care of
calling the C page fault handler and resume execution at the original
faulting instruction. This assembly routine is the handler that will be
registered with the kernel using <code class="docutils literal notranslate"><span class="pre">sys_env_set_pgfault_upcall()</span></code>.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 10.</strong>
Implement the <code class="docutils literal notranslate"><span class="pre">_pgfault_upcall</span></code> routine in
<code class="docutils literal notranslate"><span class="pre">lib/pfentry.S</span></code>. The interesting part is returning to the original
point in the user code that caused the page fault. You’ll return
directly there, without going back through the kernel. The hard part is
simultaneously switching stacks and re-loading the EIP.</p>
</div>
<p>Finally, you need to implement the C user library side of the user-level
page fault handling mechanism.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 11.</strong>
Finish <code class="docutils literal notranslate"><span class="pre">set_pgfault_handler()</span></code> in <code class="docutils literal notranslate"><span class="pre">lib/pgfault.c</span></code>.</p>
</div>
</section>
<section id="testing">
<h2>Testing<a class="headerlink" href="#testing" title="Permalink to this heading">¶</a></h2>
<p>Run <code class="docutils literal notranslate"><span class="pre">user/faultread</span></code> (make run-faultread). You should see:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="p">[</span><span class="mi">00000000</span><span class="p">]</span> <span class="n">new</span> <span class="n">env</span> <span class="mi">00001000</span>
<span class="p">[</span><span class="mi">00001000</span><span class="p">]</span> <span class="n">user</span> <span class="n">fault</span> <span class="n">va</span> <span class="mi">00000000</span> <span class="n">ip</span> <span class="mi">0080003</span><span class="n">a</span>
<span class="n">TRAP</span> <span class="n">frame</span> <span class="o">...</span>
<span class="p">[</span><span class="mi">00001000</span><span class="p">]</span> <span class="n">free</span> <span class="n">env</span> <span class="mi">00001000</span>
</pre></div>
</div>
<p>Run <code class="docutils literal notranslate"><span class="pre">user/faultdie</span></code>. You should see:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="p">[</span><span class="mi">00000000</span><span class="p">]</span> <span class="n">new</span> <span class="n">env</span> <span class="mi">00001000</span>
<span class="n">i</span> <span class="n">faulted</span> <span class="n">at</span> <span class="n">va</span> <span class="n">deadbeef</span><span class="p">,</span> <span class="n">err</span> <span class="mi">6</span>
<span class="p">[</span><span class="mi">00001000</span><span class="p">]</span> <span class="n">exiting</span> <span class="n">gracefully</span>
<span class="p">[</span><span class="mi">00001000</span><span class="p">]</span> <span class="n">free</span> <span class="n">env</span> <span class="mi">00001000</span>
</pre></div>
</div>
<p>Run <code class="docutils literal notranslate"><span class="pre">user/faultalloc</span></code>. You should see:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="p">[</span><span class="mi">00000000</span><span class="p">]</span> <span class="n">new</span> <span class="n">env</span> <span class="mi">00001000</span>
<span class="n">fault</span> <span class="n">deadbeef</span>
<span class="n">this</span> <span class="n">string</span> <span class="n">was</span> <span class="n">faulted</span> <span class="ow">in</span> <span class="n">at</span> <span class="n">deadbeef</span>
<span class="n">fault</span> <span class="n">cafebffe</span>
<span class="n">fault</span> <span class="n">cafec000</span>
<span class="n">this</span> <span class="n">string</span> <span class="n">was</span> <span class="n">faulted</span> <span class="ow">in</span> <span class="n">at</span> <span class="n">cafebffe</span>
<span class="p">[</span><span class="mi">00001000</span><span class="p">]</span> <span class="n">exiting</span> <span class="n">gracefully</span>
<span class="p">[</span><span class="mi">00001000</span><span class="p">]</span> <span class="n">free</span> <span class="n">env</span> <span class="mi">00001000</span>
</pre></div>
</div>
<p>If you see only the first “this string” line, it means you are not
handling recursive page faults properly.</p>
<p>Run <code class="docutils literal notranslate"><span class="pre">user/faultallocbad</span></code>. You should see:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="p">[</span><span class="mi">00000000</span><span class="p">]</span> <span class="n">new</span> <span class="n">env</span> <span class="mi">00001000</span>
<span class="p">[</span><span class="mi">00001000</span><span class="p">]</span> <span class="n">user_mem_check</span> <span class="n">assertion</span> <span class="n">failure</span> <span class="k">for</span> <span class="n">va</span> <span class="n">deadbeef</span>
<span class="p">[</span><span class="mi">00001000</span><span class="p">]</span> <span class="n">free</span> <span class="n">env</span> <span class="mi">00001000</span>
</pre></div>
</div>
<p>Make sure you understand why <code class="docutils literal notranslate"><span class="pre">user/faultalloc</span></code> and
<code class="docutils literal notranslate"><span class="pre">user/faultallocbad</span></code> behave differently.</p>
<div class="admonition-challenge admonition">
<p class="admonition-title">Challenge</p>
<p><strong>Challenge!</strong>
Extend your kernel so that not only page faults, but <em>all</em>
types of processor exceptions that code running in user space can
generate, can be redirected to a user-mode exception handler. Write
user-mode test programs to test user-mode handling of various exceptions
such as divide-by-zero, general protection fault, and illegal opcode.</p>
</div>
<section id="implementing-copy-on-write-fork">
<h3>Implementing Copy-on-Write Fork<a class="headerlink" href="#implementing-copy-on-write-fork" title="Permalink to this heading">¶</a></h3>
<p>You now have the kernel facilities to implement copy-on-write <code class="docutils literal notranslate"><span class="pre">fork()</span></code>
entirely in user space.</p>
<p>We have provided a skeleton for your <code class="docutils literal notranslate"><span class="pre">fork()</span></code> in <code class="docutils literal notranslate"><span class="pre">lib/fork.c</span></code>. Like
<code class="docutils literal notranslate"><span class="pre">dumbfork()</span></code>, <code class="docutils literal notranslate"><span class="pre">fork()</span></code> should create a new environment, then scan
through the parent environment’s entire address space and set up
corresponding page mappings in the child. The key difference is that,
while <code class="docutils literal notranslate"><span class="pre">dumbfork()</span></code> copied <em>pages</em>, <code class="docutils literal notranslate"><span class="pre">fork()</span></code> will initially only copy
page <em>mappings</em>. <code class="docutils literal notranslate"><span class="pre">fork()</span></code> will copy each page only when one of the
environments tries to write it.</p>
<p>The basic control flow for <code class="docutils literal notranslate"><span class="pre">fork()</span></code> is as follows:</p>
<ol class="arabic">
<li><p>The parent installs <code class="docutils literal notranslate"><span class="pre">pgfault()</span></code> as the C-level page fault handler,
using the <code class="docutils literal notranslate"><span class="pre">set_pgfault_handler()</span></code> function you implemented above.</p></li>
<li><p>The parent calls <code class="docutils literal notranslate"><span class="pre">sys_exofork()</span></code> to create a child environment.</p></li>
<li><p>For each writable or copy-on-write page in its address space below
UTOP, the parent calls <code class="docutils literal notranslate"><span class="pre">duppage</span></code>, which should map the page
copy-on-write into the address space of the child and then <em>remap</em>
the page copy-on-write in its own address space. <code class="docutils literal notranslate"><span class="pre">duppage</span></code> sets
both PTEs so that the page is not writeable, and to contain
<code class="docutils literal notranslate"><span class="pre">PTE_COW</span></code> in the “avail” field to distinguish copy-on-write pages
from genuine read-only pages.</p>
<p>The exception stack is <em>not</em> remapped this way, however. Instead you
need to allocate a fresh page in the child for the exception stack.
Since the page fault handler will be doing the actual copying and the
page fault handler runs on the exception stack, the exception stack
cannot be made copy-on-write: who would copy it?</p>
<p><code class="docutils literal notranslate"><span class="pre">fork()</span></code> also needs to handle pages that are present, but not
writable or copy-on-write.</p>
</li>
<li><p>The parent sets the user page fault entrypoint for the child to look
like its own.</p></li>
<li><p>The child is now ready to run, so the parent marks it runnable.</p></li>
</ol>
<p>Each time one of the environments writes a copy-on-write page that it
hasn’t yet written, it will take a page fault. Here’s the control flow
for the user page fault handler:</p>
<ol class="arabic simple">
<li><p>The kernel propagates the page fault to <code class="docutils literal notranslate"><span class="pre">_pgfault_upcall</span></code>, which
calls <code class="docutils literal notranslate"><span class="pre">fork()</span></code>’s <code class="docutils literal notranslate"><span class="pre">pgfault()</span></code> handler.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pgfault()</span></code> checks that the fault is a write (check for <code class="docutils literal notranslate"><span class="pre">FEC_WR</span></code>
in the error code) and that the PTE for the page is marked
<code class="docutils literal notranslate"><span class="pre">PTE_COW</span></code>. If not, panic.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pgfault()</span></code> allocates a new page mapped at a temporary location and
copies the contents of the faulting page into it. Then the fault
handler maps the new page at the appropriate address with read/write
permissions, in place of the old read-only mapping.</p></li>
</ol>
<p>The user-level <code class="docutils literal notranslate"><span class="pre">lib/fork.c</span></code> code must consult the environment’s page
tables for several of the operations above (e.g., that the PTE for a
page is marked <code class="docutils literal notranslate"><span class="pre">PTE_COW</span></code>). The kernel maps the environment’s page
tables at <code class="docutils literal notranslate"><span class="pre">UVPT</span></code> exactly for this purpose. It uses a <a class="reference external" href="https://pdos.csail.mit.edu/6.828/2014/labs/lab4/uvpt.html">clever mapping
trick</a>
to make it to make it easy to lookup PTEs for user
code. <code class="docutils literal notranslate"><span class="pre">lib/entry.S</span></code> sets up <code class="docutils literal notranslate"><span class="pre">uvpt</span></code> and <code class="docutils literal notranslate"><span class="pre">uvpd</span></code> so that you can
easily lookup page-table information in <code class="docutils literal notranslate"><span class="pre">lib/fork.c</span></code>.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 12.</strong> Implement <code class="docutils literal notranslate"><span class="pre">fork</span></code>, <code class="docutils literal notranslate"><span class="pre">duppage</span></code> and <code class="docutils literal notranslate"><span class="pre">pgfault</span></code> in
<code class="docutils literal notranslate"><span class="pre">lib/fork.c</span></code>.</p>
<p>Test your code with the <code class="docutils literal notranslate"><span class="pre">forktree</span></code> program. It should produce the
following messages, with interspersed ‘new env’, ‘free env’, and
‘exiting gracefully’ messages. The messages may not appear in this
order, and the environment IDs may be different.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1000</span><span class="p">:</span> <span class="n">I</span> <span class="n">am</span> <span class="s1">&#39;&#39;</span>
<span class="mi">1001</span><span class="p">:</span> <span class="n">I</span> <span class="n">am</span> <span class="s1">&#39;0&#39;</span>
<span class="mi">2000</span><span class="p">:</span> <span class="n">I</span> <span class="n">am</span> <span class="s1">&#39;00&#39;</span>
<span class="mi">2001</span><span class="p">:</span> <span class="n">I</span> <span class="n">am</span> <span class="s1">&#39;000&#39;</span>
<span class="mi">1002</span><span class="p">:</span> <span class="n">I</span> <span class="n">am</span> <span class="s1">&#39;1&#39;</span>
<span class="mi">3000</span><span class="p">:</span> <span class="n">I</span> <span class="n">am</span> <span class="s1">&#39;11&#39;</span>
<span class="mi">3001</span><span class="p">:</span> <span class="n">I</span> <span class="n">am</span> <span class="s1">&#39;10&#39;</span>
<span class="mi">4000</span><span class="p">:</span> <span class="n">I</span> <span class="n">am</span> <span class="s1">&#39;100&#39;</span>
<span class="mi">1003</span><span class="p">:</span> <span class="n">I</span> <span class="n">am</span> <span class="s1">&#39;01&#39;</span>
<span class="mi">5000</span><span class="p">:</span> <span class="n">I</span> <span class="n">am</span> <span class="s1">&#39;010&#39;</span>
<span class="mi">4001</span><span class="p">:</span> <span class="n">I</span> <span class="n">am</span> <span class="s1">&#39;011&#39;</span>
<span class="mi">2002</span><span class="p">:</span> <span class="n">I</span> <span class="n">am</span> <span class="s1">&#39;110&#39;</span>
<span class="mi">1004</span><span class="p">:</span> <span class="n">I</span> <span class="n">am</span> <span class="s1">&#39;001&#39;</span>
<span class="mi">1005</span><span class="p">:</span> <span class="n">I</span> <span class="n">am</span> <span class="s1">&#39;111&#39;</span>
<span class="mi">1006</span><span class="p">:</span> <span class="n">I</span> <span class="n">am</span> <span class="s1">&#39;101&#39;</span>
</pre></div>
</div>
</div>
<div class="admonition-challenge admonition">
<p class="admonition-title">Challenge</p>
<p><strong>Challenge!</strong>
Implement a shared-memory <code class="docutils literal notranslate"><span class="pre">fork()</span></code> called <code class="docutils literal notranslate"><span class="pre">sfork()</span></code>. This
version should have the parent and child <em>share</em> all their memory pages
(so writes in one environment appear in the other) except for pages in
the stack area, which should be treated in the usual copy-on-write
manner. Modify <code class="docutils literal notranslate"><span class="pre">user/forktree.c</span></code> to use <code class="docutils literal notranslate"><span class="pre">sfork()</span></code> instead of regular
<code class="docutils literal notranslate"><span class="pre">fork()</span></code>. Also, once you have finished implementing IPC in part C, use
your <code class="docutils literal notranslate"><span class="pre">sfork()</span></code> to run <code class="docutils literal notranslate"><span class="pre">user/pingpongs</span></code>. You will have to find a new
way to provide the functionality of the global <code class="docutils literal notranslate"><span class="pre">thisenv</span></code> pointer.</p>
</div>
<div class="admonition-challenge admonition">
<p class="admonition-title">Challenge</p>
<p><strong>Challenge!</strong>
Your implementation of <code class="docutils literal notranslate"><span class="pre">fork</span></code> makes a huge number of system
calls. On the x86, switching into the kernel using interrupts has
non-trivial cost. Augment the system call interface so that it is
possible to send a batch of system calls at once. Then change <code class="docutils literal notranslate"><span class="pre">fork</span></code>
to use this interface.</p>
<p>How much faster is your new <code class="docutils literal notranslate"><span class="pre">fork</span></code>?</p>
<p>You can answer this (roughly) by using analytical arguments to estimate
how much of an improvement batching system calls will make to the
performance of your <code class="docutils literal notranslate"><span class="pre">fork</span></code>: How expensive is an <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">0x30</span></code>
instruction? How many times do you execute <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">0x30</span></code> in your
<code class="docutils literal notranslate"><span class="pre">fork</span></code>? Is accessing the <code class="docutils literal notranslate"><span class="pre">TSS</span></code> stack switch also expensive? And so
on…</p>
<p>Alternatively, you can boot your kernel on real hardware and <em>really</em>
benchmark your code. See the <code class="docutils literal notranslate"><span class="pre">RDTSC</span></code> (read time-stamp counter)
instruction, defined in the IA32 manual, which counts the number of
clock cycles that have elapsed since the last processor reset. QEMU
doesn’t emulate this instruction faithfully (it can either count the
number of virtual instructions executed or use the host TSC, neither of
which reflects the number of cycles a real CPU would require).</p>
</div>
<p>This ends part B. As usual, you can grade your submission with make
grade and hand it in by committing, tagging, and pushing to GitHub.</p>
</section>
</section>
<section id="part-c-preemptive-multitasking-and-inter-process-communication-ipc">
<h2>Part C: Preemptive Multitasking and Inter-Process communication (IPC)<a class="headerlink" href="#part-c-preemptive-multitasking-and-inter-process-communication-ipc" title="Permalink to this heading">¶</a></h2>
<p>In the final part of lab 4 you will modify the kernel to preempt
uncooperative environments and to allow environments to pass messages to
each other explicitly.</p>
<section id="clock-interrupts-and-preemption">
<h3>Clock Interrupts and Preemption<a class="headerlink" href="#clock-interrupts-and-preemption" title="Permalink to this heading">¶</a></h3>
<p>Run the <code class="docutils literal notranslate"><span class="pre">user/spin</span></code> test program. This test program forks off a child
environment, which simply spins forever in a tight loop once it receives
control of the CPU. Neither the parent environment nor the kernel ever
regains the CPU. This is obviously not an ideal situation in terms of
protecting the system from bugs or malicious code in user-mode
environments, because any user-mode environment can bring the whole
system to a halt simply by getting into an infinite loop and never
giving back the CPU. In order to allow the kernel to <em>preempt</em> a running
environment, forcefully retaking control of the CPU from it, we must
extend the JOS kernel to support external hardware interrupts from the
clock hardware.</p>
</section>
</section>
<section id="interrupt-discipline">
<h2>Interrupt discipline<a class="headerlink" href="#interrupt-discipline" title="Permalink to this heading">¶</a></h2>
<p>External interrupts (i.e., device interrupts) are referred to as IRQs.
There are 16 possible IRQs, numbered 0 through 15. The mapping from IRQ
number to IDT entry is not fixed. <code class="docutils literal notranslate"><span class="pre">pic_init</span></code> in <code class="docutils literal notranslate"><span class="pre">picirq.c</span></code> maps IRQs
0-15 to IDT entries <code class="docutils literal notranslate"><span class="pre">IRQ_OFFSET</span></code> through <code class="docutils literal notranslate"><span class="pre">IRQ_OFFSET+15</span></code>.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">inc/trap.h</span></code>, <code class="docutils literal notranslate"><span class="pre">IRQ_OFFSET</span></code> is defined to be decimal 32. Thus the
IDT entries 32-47 correspond to the IRQs 0-15. For example, the clock
interrupt is IRQ 0. Thus, <code class="docutils literal notranslate"><span class="pre">IDT[IRQ_OFFSET+0]</span></code> (i.e., IDT[32]) contains
the address of the clock’s interrupt handler routine in the kernel. This
<code class="docutils literal notranslate"><span class="pre">IRQ_OFFSET</span></code> is chosen so that the device interrupts do not overlap
with the processor exceptions, which could obviously cause confusion.
(In fact, in the early days of PCs running MS-DOS, the <code class="docutils literal notranslate"><span class="pre">IRQ_OFFSET</span></code>
effectively <em>was</em> zero, which indeed caused massive confusion between
handling hardware interrupts and handling processor exceptions!)</p>
<p>In JOS, we make a key simplification compared to xv6 Unix. External
device interrupts are <em>always</em> disabled when in the kernel (and, like
xv6, enabled when in user space). External interrupts are controlled by
the <code class="docutils literal notranslate"><span class="pre">FL_IF</span></code> flag bit of the <code class="docutils literal notranslate"><span class="pre">%eflags</span></code> register (see <code class="docutils literal notranslate"><span class="pre">inc/mmu.h</span></code>).
When this bit is set, external interrupts are enabled. While the bit can
be modified in several ways, because of our simplification, we will
handle it solely through the process of saving and restoring <code class="docutils literal notranslate"><span class="pre">%eflags</span></code>
register as we enter and leave user mode.</p>
<p>You will have to ensure that the <code class="docutils literal notranslate"><span class="pre">FL_IF</span></code> flag is set in user
environments when they run so that when an interrupt arrives, it gets
passed through to the processor and handled by your interrupt code.
Otherwise, interrupts are <em>masked</em>, or ignored until interrupts are
re-enabled. We masked interrupts with the very first instruction of the
bootloader, and so far we have never gotten around to re-enabling them.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 13.</strong>
Modify <code class="docutils literal notranslate"><span class="pre">kern/trapentry.S</span></code> and <code class="docutils literal notranslate"><span class="pre">kern/trap.c</span></code> to
initialize the appropriate entries in the IDT and provide handlers for
IRQs 0 through 15. Then modify the code in <code class="docutils literal notranslate"><span class="pre">env_alloc()</span></code> in
<code class="docutils literal notranslate"><span class="pre">kern/env.c</span></code> to ensure that user environments are always run with
interrupts enabled.</p>
<p>The processor never pushes an error code or checks the Descriptor
Privilege Level (DPL) of the IDT entry when invoking a hardware
interrupt handler. You might want to re-read section 9.2 of the <a class="reference external" href="http://www.logix.cz/michal/doc/i386/">80386
Reference Manual</a>, or section 5.8 of the
<a class="reference external" href="../r/ia32/IA32-3A.pdf">IA-32 Intel Architecture Software Developer’s Manual, Volume
3</a>, at this time.</p>
<p>After doing this exercise, if you run your kernel with any test program
that runs for a non-trivial length of time (e.g., <code class="docutils literal notranslate"><span class="pre">spin</span></code>), you should
see the kernel print trap frames for hardware interrupts. While
interrupts are now enabled in the processor, JOS isn’t yet handling
them, so you should see it misattribute each interrupt to the currently
running user environment and destroy it. Eventually it should run out of
environments to destroy and drop into the monitor.</p>
</div>
</section>
<section id="handling-clock-interrupts">
<h2>Handling Clock Interrupts<a class="headerlink" href="#handling-clock-interrupts" title="Permalink to this heading">¶</a></h2>
<p>In the <code class="docutils literal notranslate"><span class="pre">user/spin</span></code> program, after the child environment was first run,
it just spun in a loop, and the kernel never got control back. We need
to program the hardware to generate clock interrupts periodically, which
will force control back to the kernel where we can switch control to a
different user environment.</p>
<p>The calls to <code class="docutils literal notranslate"><span class="pre">lapic_init</span></code> and <code class="docutils literal notranslate"><span class="pre">pic_init</span></code> (from <code class="docutils literal notranslate"><span class="pre">i386_init</span></code> in
<code class="docutils literal notranslate"><span class="pre">init.c</span></code>), which we have written for you, set up the clock and the
interrupt controller to generate interrupts. You now need to write the
code to handle these interrupts.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 14.</strong>
Modify the kernel’s <code class="docutils literal notranslate"><span class="pre">trap_dispatch()</span></code> function so that it
calls <code class="docutils literal notranslate"><span class="pre">sched_yield()</span></code> to find and run a different environment whenever
a clock interrupt takes place.</p>
<p>You should now be able to get the <code class="docutils literal notranslate"><span class="pre">user/spin</span></code> test to work: the parent
environment should fork off the child, <code class="docutils literal notranslate"><span class="pre">sys_yield()</span></code> to it a couple
times but in each case regain control of the CPU after one time slice,
and finally kill the child environment and terminate gracefully.</p>
</div>
<p>This is a great time to do some <em>regression testing</em>. Make sure that you
haven’t broken any earlier part of that lab that used to work (e.g.
<code class="docutils literal notranslate"><span class="pre">forktree</span></code>) by enabling interrupts. Also, try running with multiple
CPUs using <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">CPUS=2</span></code> <em>target</em>. You should also be able to pass
<code class="docutils literal notranslate"><span class="pre">stresssched</span></code> now. Run make grade to see for sure. You should now get
a total score of 65/75 points on this lab.</p>
<section id="inter-process-communication-ipc">
<h3>Inter-Process communication (IPC)<a class="headerlink" href="#inter-process-communication-ipc" title="Permalink to this heading">¶</a></h3>
<p>(Technically in JOS this is “inter-environment communication” or “IEC”,
but everyone else calls it IPC, so we’ll use the standard term.)</p>
<p>We’ve been focusing on the isolation aspects of the operating system,
the ways it provides the illusion that each program has a machine all to
itself. Another important service of an operating system is to allow
programs to communicate with each other when they want to. It can be
quite powerful to let programs interact with other programs. The Unix
pipe model is the canonical example.</p>
<p>There are many models for interprocess communication. Even today there
are still debates about which models are best. We won’t get into that
debate. Instead, we’ll implement a simple IPC mechanism and then try it
out.</p>
</section>
</section>
<section id="ipc-in-jos">
<h2>IPC in JOS<a class="headerlink" href="#ipc-in-jos" title="Permalink to this heading">¶</a></h2>
<p>You will implement a few additional JOS kernel system calls that
collectively provide a simple interprocess communication mechanism. You
will implement two system calls, <code class="docutils literal notranslate"><span class="pre">sys_ipc_recv</span></code> and
<code class="docutils literal notranslate"><span class="pre">sys_ipc_try_send</span></code>. Then you will implement two library wrappers
<code class="docutils literal notranslate"><span class="pre">ipc_recv</span></code> and <code class="docutils literal notranslate"><span class="pre">ipc_send</span></code>.</p>
<p>The “messages” that user environments can send to each other using JOS’s
IPC mechanism consist of two components: a single 32-bit value, and
optionally a single page mapping. Allowing environments to pass page
mappings in messages provides an efficient way to transfer more data
than will fit into a single 32-bit integer, and also allows environments
to set up shared memory arrangements easily.</p>
</section>
<section id="sending-and-receiving-messages">
<h2>Sending and Receiving Messages<a class="headerlink" href="#sending-and-receiving-messages" title="Permalink to this heading">¶</a></h2>
<p>To receive a message, an environment calls <code class="docutils literal notranslate"><span class="pre">sys_ipc_recv</span></code>. This system
call de-schedules the current environment and does not run it again
until a message has been received. When an environment is waiting to
receive a message, <em>any</em> other environment can send it a message - not
just a particular environment, and not just environments that have a
parent/child arrangement with the receiving environment. In other words,
the permission checking that you implemented in Part A will not apply to
IPC, because the IPC system calls are carefully designed so as to be
“safe”: an environment cannot cause another environment to malfunction
simply by sending it messages (unless the target environment is also
buggy).</p>
<p>To try to send a value, an environment calls <code class="docutils literal notranslate"><span class="pre">sys_ipc_try_send</span></code> with
both the receiver’s environment id and the value to be sent. If the
named environment is actually receiving (it has called <code class="docutils literal notranslate"><span class="pre">sys_ipc_recv</span></code>
and not gotten a value yet), then the send delivers the message and
returns 0. Otherwise the send returns <code class="docutils literal notranslate"><span class="pre">-E_IPC_NOT_RECV</span></code> to indicate
that the target environment is not currently expecting to receive a
value.</p>
<p>A library function <code class="docutils literal notranslate"><span class="pre">ipc_recv</span></code> in user space will take care of calling
<code class="docutils literal notranslate"><span class="pre">sys_ipc_recv</span></code> and then looking up the information about the received
values in the current environment’s <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Env</span></code>.</p>
<p>Similarly, a library function <code class="docutils literal notranslate"><span class="pre">ipc_send</span></code> will take care of repeatedly
calling <code class="docutils literal notranslate"><span class="pre">sys_ipc_try_send</span></code> until the send succeeds.</p>
</section>
<section id="transferring-pages">
<h2>Transferring Pages<a class="headerlink" href="#transferring-pages" title="Permalink to this heading">¶</a></h2>
<p>When an environment calls <code class="docutils literal notranslate"><span class="pre">sys_ipc_recv</span></code> with a valid <code class="docutils literal notranslate"><span class="pre">dstva</span></code>
parameter (below <code class="docutils literal notranslate"><span class="pre">UTOP</span></code>), the environment is stating that it is
willing to receive a page mapping. If the sender sends a page, then that
page should be mapped at <code class="docutils literal notranslate"><span class="pre">dstva</span></code> in the receiver’s address space. If
the receiver already had a page mapped at <code class="docutils literal notranslate"><span class="pre">dstva</span></code>, then that previous
page is unmapped.</p>
<p>When an environment calls <code class="docutils literal notranslate"><span class="pre">sys_ipc_try_send</span></code> with a valid <code class="docutils literal notranslate"><span class="pre">srcva</span></code>
(below <code class="docutils literal notranslate"><span class="pre">UTOP</span></code>), it means the sender wants to send the page currently
mapped at <code class="docutils literal notranslate"><span class="pre">srcva</span></code> to the receiver, with permissions <code class="docutils literal notranslate"><span class="pre">perm</span></code>. After a
successful IPC, the sender keeps its original mapping for the page at
<code class="docutils literal notranslate"><span class="pre">srcva</span></code> in its address space, but the receiver also obtains a mapping
for this same physical page at the <code class="docutils literal notranslate"><span class="pre">dstva</span></code> originally specified by the
receiver, in the receiver’s address space. As a result this page becomes
shared between the sender and receiver.</p>
<p>If either the sender or the receiver does not indicate that a page
should be transferred, then no page is transferred. After any IPC the
kernel sets the new field <code class="docutils literal notranslate"><span class="pre">env_ipc_perm</span></code> in the receiver’s <code class="docutils literal notranslate"><span class="pre">Env</span></code>
structure to the permissions of the page received, or zero if no page
was received.</p>
</section>
<section id="implementing-ipc">
<h2>Implementing IPC<a class="headerlink" href="#implementing-ipc" title="Permalink to this heading">¶</a></h2>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 15.</strong>
Implement <code class="docutils literal notranslate"><span class="pre">sys_ipc_recv</span></code> and <code class="docutils literal notranslate"><span class="pre">sys_ipc_try_send</span></code> in
<code class="docutils literal notranslate"><span class="pre">kern/syscall.c</span></code>. Read the comments on both before implementing them,
since they have to work together. When you call <code class="docutils literal notranslate"><span class="pre">envid2env</span></code> in these
routines, you should set the <code class="docutils literal notranslate"><span class="pre">checkperm</span></code> flag to 0, meaning that any
environment is allowed to send IPC messages to any other environment,
and the kernel does no special permission checking other than verifying
that the target envid is valid.</p>
<p>Then implement the <code class="docutils literal notranslate"><span class="pre">ipc_recv</span></code> and <code class="docutils literal notranslate"><span class="pre">ipc_send</span></code> functions in
<code class="docutils literal notranslate"><span class="pre">lib/ipc.c</span></code>.</p>
<p>Use the <code class="docutils literal notranslate"><span class="pre">user/pingpong</span></code> and <code class="docutils literal notranslate"><span class="pre">user/primes</span></code> functions to test your IPC
mechanism. <code class="docutils literal notranslate"><span class="pre">user/primes</span></code> will generate for each prime number a new
environment until JOS runs out of environments. You might find it
interesting to read <code class="docutils literal notranslate"><span class="pre">user/primes.c</span></code> to see all the forking and IPC
going on behind the scenes.</p>
</div>
<div class="admonition-challenge admonition">
<p class="admonition-title">Challenge</p>
<p><strong>Challenge!</strong>
Why does <code class="docutils literal notranslate"><span class="pre">ipc_send</span></code> have to loop? Change the system call
interface so it doesn’t have to. Make sure you can handle multiple
environments trying to send to one environment at the same time.</p>
</div>
<div class="admonition-challenge admonition">
<p class="admonition-title">Challenge</p>
<p><strong>Challenge!</strong>
The prime sieve is only one neat use of message passing
between a large number of concurrent programs. Read C. A. R. Hoare,
Communicating Sequential Processes, <em>Communications of the ACM</em>
21(8) (August 1978), 666-667, and implement the matrix multiplication
example.</p>
</div>
<div class="admonition-challenge admonition">
<p class="admonition-title">Challenge</p>
<p><strong>Challenge!</strong>
One of the most impressive examples of the power of message
passing is Doug McIlroy’s power series calculator, described in <a class="reference external" href="https://swtch.com/~rsc/thread/squint.pdf">M.
Douglas McIlroy, Squinting at Power Series, *Software–Practice
and Experience*, 20(7) (July 1990),
661-683</a>.
Implement his power series calculator and compute the power series for
<em>sin</em>(<em>x</em>+<em>x</em>^3).</p>
</div>
<div class="admonition-challenge admonition">
<p class="admonition-title">Challenge</p>
<p><strong>Challenge!</strong>
Make JOS’s IPC mechanism more efficient by applying some of
the techniques from Liedtke’s paper, <a class="reference external" href="http://dl.acm.org/citation.cfm?id=168633">Improving IPC by Kernel
Design</a>, or any other
tricks you may think of. Feel free to modify the kernel’s system call
API for this purpose, as long as your code is backwards compatible with
what our grading scripts expect.</p>
</div>
<p><strong>This ends part C.</strong> Make sure you pass all of the make grade tests and
don’t forget to write up your answers to the questions and a description
of your challenge exercise solution in <code class="docutils literal notranslate"><span class="pre">answers-lab4.txt</span></code>.</p>
<p>Before handing in, use git status and git diff to examine your changes
and don’t forget to git add answers-lab4.txt. When you’re ready, commit
your changes with git commit -am ‘my solutions to lab 4’, then tag and push to GitHub.</p>
<script src="../_static/disqus/disqus.js"></script>
<link rel="stylesheet" type="text/css" href="../_static/disqus/disqus.css" />

<script>
  disqus_shortname = 'gatechcs3210staff';
  $(document).ready(function() {
    $("p").inlineDisqussions();
  });
</script></section>
</section>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="lab5.html" class="btn btn-neutral float-right" title="Lab 5: File system, Spawn and Shell">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="lab3.html" class="btn btn-neutral" title="Lab 3: User Environments"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
      Last updated on Jul 02, 2022.
    </p>
  </div>

</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

<script src="../_static/email.js"></script>
<script src="../_static/custom.js"></script>

</body>
</html>