

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Lab 6: Network Driver &mdash; CS 323, Fall 2022 1 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
  
  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="CS 323, Fall 2022 1 documentation" href="../index.html"/>
        <link rel="up" title="Lab" href="../lab.html"/>
        <link rel="next" title="Final Project" href="../proj.html"/>
        <link rel="prev" title="Lab 5: File system, Spawn and Shell" href="lab5.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../index.html" class="fa fa-home"> CS 323, Fall 2022</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../info.html">General Information</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../info.html#prerequisite">Prerequisite</a></li>
<li class="toctree-l2"><a class="reference internal" href="../info.html#meetings">Meetings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../info.html#grades">Grades</a></li>
<li class="toctree-l2"><a class="reference internal" href="../info.html#labs">Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../info.html#prep-questions">Prep Questions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../info.html#equipment-problems">Equipment Problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../info.html#other-policies">Other Policies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../info.html#text">Text</a></li>
<li class="toctree-l2"><a class="reference internal" href="../info.html#staff-ta">Staff/TA</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cal.html">Schedule</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../q.html">Preparation Questions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../refs.html">Reference Materials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../refs.html#c-programming">C Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../refs.html#unix">UNIX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../refs.html#x86-emulation">x86 Emulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../refs.html#x86-assembly-language">x86 Assembly Language</a></li>
<li class="toctree-l2"><a class="reference internal" href="../refs.html#pc-hardware-programming">PC Hardware Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../refs.html#reference-quizzes">Reference Quizzes</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../lab.html">Lab</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab1.html">Lab 1: Booting a PC</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab2.html">Lab 2: Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab3.html">Lab 3: User Environments</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab4.html">Lab 4: Preemptive Multitasking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab5.html">Lab 5: File system, Spawn and Shell</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Lab 6: Network Driver</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proj.html">Final Project</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../proj.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proj.html#deliverables">Deliverables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../proj.html#project-ideas-if-you-found-none">Project ideas (if you found none)</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">CS 323, Fall 2022</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../lab.html">Lab</a> &raquo;</li>
      
    <li>Lab 6: Network Driver</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../_sources/lab/lab6.rst.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <section id="lab-6-network-driver">
<h1>Lab 6: Network Driver<a class="headerlink" href="#lab-6-network-driver" title="Permalink to this heading">¶</a></h1>
<ul class="simple">
<li><p><strong>Handed out:</strong> Thursday, Nov 16, 2017</p></li>
<li><p><strong>Due:</strong> Friday, Dec 15, 2017 (No late submissions)</p></li>
</ul>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h2>
<p>This lab is the default final project that you can do on your own.</p>
<p>Now that you have a file system, no self respecting OS should go without
a network stack. In this lab, you are going to write a driver for a
network interface card. The card will be based on the Intel 82540EM
chip, also known as E1000.</p>
<section id="getting-started">
<h3>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this heading">¶</a></h3>
<p>Use Git to commit your Lab 5 source (if you haven’t already), fetch the
latest version of the course repository, and then create a local branch
called <code class="docutils literal notranslate"><span class="pre">lab6</span></code> based on our lab6 branch, <code class="docutils literal notranslate"><span class="pre">origin/lab6</span></code>:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ <span class="nb">cd</span> ~/cs3210/lab
$ add git
$ git commit -am <span class="s1">&#39;my solution to lab5&#39;</span>
nothing to commit <span class="o">(</span>working directory clean<span class="o">)</span>
$ git pull
Already up-to-date.
$ git checkout -b lab6 origin/lab6
Branch lab6 <span class="nb">set</span> up to track remote branch refs/remotes/origin/lab6.
Switched to a new branch <span class="s2">&quot;lab6&quot;</span>
$ git merge lab5
Merge made by recursive.
 fs/fs.c <span class="p">|</span>   <span class="m">42</span> +++++++++++++++++++
 <span class="m">1</span> files changed, <span class="m">42</span> insertions<span class="o">(</span>+<span class="o">)</span>, <span class="m">0</span> deletions<span class="o">(</span>-<span class="o">)</span>
</pre></div>
</div>
<p>The network card driver, however, will not be enough to get your OS
hooked up to the Internet. In the new lab6 code, we have provided you
with a network stack and a network server. As in previous labs, use git
to grab the code for this lab, merge in your own code, and explore the
contents of the new <code class="docutils literal notranslate"><span class="pre">net/</span></code> directory, as well as the new files in
<code class="docutils literal notranslate"><span class="pre">kern/</span></code>.</p>
<p>In addition to writing the driver, you will need to create a system call
interface to give access to your driver. You will implement missing
network server code to transfer packets between the network stack and
your driver. You will also tie everything together by finishing a web
server. With the new web server you will be able to serve files from
your file system.</p>
<p>Much of the kernel device driver code you will have to write yourself
from scratch. This lab provides much less guidance than previous labs:
there are no skeleton files, no system call interfaces written in stone,
and many design decisions are left up to you. For this reason, we
recommend that you read the entire assignment write up before starting
any individual exercises. Many students find this lab more difficult
than previous labs, so please plan your time accordingly.</p>
</section>
<section id="lab-requirements">
<h3>Lab Requirements<a class="headerlink" href="#lab-requirements" title="Permalink to this heading">¶</a></h3>
<p>As before, you will need to do all of the regular exercises described in
the lab and <em>at least one</em> challenge problem. Write up brief answers to
the questions posed in the lab and a description of your challenge
exercise in <code class="docutils literal notranslate"><span class="pre">answers-lab6.txt</span></code>.</p>
</section>
</section>
<section id="qemu-s-virtual-network">
<h2>QEMU’s virtual network<a class="headerlink" href="#qemu-s-virtual-network" title="Permalink to this heading">¶</a></h2>
<p>We will be using QEMU’s user mode network stack since it requires no
administrative privileges to run. QEMU’s documentation has more about
user-net
<a class="reference external" href="http://wiki.qemu.org/download/qemu-doc.html#Using-the-user-mode-network-stack">here</a>.
We’ve updated the makefile to enable QEMU’s user-mode network stack and
the virtual E1000 network card.</p>
<p>By default, QEMU provides a virtual router running on IP 10.0.2.2 and
will assign JOS the IP address 10.0.2.15. To keep things simple, we
hard-code these defaults into the network server in <code class="docutils literal notranslate"><span class="pre">net/ns.h</span></code>.</p>
<p>While QEMU’s virtual network allows JOS to make arbitrary connections
out to the Internet, JOS’s 10.0.2.15 address has no meaning outside the
virtual network running inside QEMU (that is, QEMU acts as a NAT), so we
can’t connect directly to servers running inside JOS, even from the host
running QEMU. To address this, we configure QEMU to run a server on some
port on the <em>host</em> machine that simply connects through to some port in
JOS and shuttles data back and forth between your real host and the
virtual network.</p>
<p>You will run JOS servers on ports 7 (echo) and 80 (http). To avoid
collisions on shared machines, the makefile generates forwarding
ports for these based on your user ID. To find out what ports QEMU is
forwarding to on your development host, run make which-ports. For
convenience, the makefile also provides <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">nc-7</span></code> and <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">nc-80</span></code>, which
allow you to interact directly with servers running on these ports in
your terminal. (These targets only connect to a running QEMU instance;
you must start QEMU itself separately.)</p>
<section id="packet-inspection">
<h3>Packet Inspection<a class="headerlink" href="#packet-inspection" title="Permalink to this heading">¶</a></h3>
<p>The makefile also configures QEMU’s network stack to record all incoming
and outgoing packets to <code class="docutils literal notranslate"><span class="pre">qemu.pcap</span></code> in your lab directory.</p>
<p>To get a hex/ASCII dump of captured packets use <code class="docutils literal notranslate"><span class="pre">tcpdump</span></code> like this:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ tcpdump -XXnr qemu.pcap
</pre></div>
</div>
<p>Alternatively, you can use <a class="reference external" href="http://www.wireshark.org/">Wireshark</a> to
graphically inspect the pcap file. Wireshark also knows how to decode
and inspect hundreds of network protocols.</p>
</section>
<section id="debugging-the-e1000">
<h3>Debugging the E1000<a class="headerlink" href="#debugging-the-e1000" title="Permalink to this heading">¶</a></h3>
<p>We are very lucky to be using emulated hardware. Since the E1000 is
running in software, the emulated E1000 can report to us, in a user
readable format, its internal state and any problems it encounters.
Normally, such a luxury would not be available to a driver developer
writing with bare metal.</p>
<p>The E1000 can produce a lot of debug output, so you have to enable
specific logging channels. Some channels you might find useful are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Flag</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tx</p></td>
<td><p>Log packet transmit operations</p></td>
</tr>
<tr class="row-odd"><td><p>txerr</p></td>
<td><p>Log transmit ring errors</p></td>
</tr>
<tr class="row-even"><td><p>rx</p></td>
<td><p>Log changes to RCTL</p></td>
</tr>
<tr class="row-odd"><td><p>rxfilter</p></td>
<td><p>Log filtering of incoming packets</p></td>
</tr>
<tr class="row-even"><td><p>rxerr</p></td>
<td><p>Log receive ring errors</p></td>
</tr>
<tr class="row-odd"><td><p>unknown</p></td>
<td><p>Log reads and writes of unknown registers</p></td>
</tr>
<tr class="row-even"><td><p>eeprom</p></td>
<td><p>Log reads from the EEPROM</p></td>
</tr>
<tr class="row-odd"><td><p>interrupt</p></td>
<td><p>Log interrupts and changes to interrupt registers.</p></td>
</tr>
</tbody>
</table>
<p>To enable “tx” and “txerr” logging, for example, use
<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">E1000_DEBUG=tx,txerr</span> <span class="pre">....</span></code></p>
<p>Note: <code class="docutils literal notranslate"><span class="pre">E1000_DEBUG</span></code> flags only work in a
<a class="reference external" href="https://pdos.csail.mit.edu/6.828/2014/tools.html">modified QEMU</a>.</p>
<p>You can take debugging using software emulated hardware one step
further. If you are ever stuck and do not understand why the E1000 is
not responding the way you would expect, you can look at QEMU’s E1000
implementation in <code class="docutils literal notranslate"><span class="pre">hw/e1000.c</span></code> (not in JOS).</p>
</section>
<section id="the-network-server">
<h3>The Network Server<a class="headerlink" href="#the-network-server" title="Permalink to this heading">¶</a></h3>
<p>Writing a network stack from scratch is hard work. Instead, we will be
using lwIP, an open source lightweight TCP/IP protocol suite that among
many things includes a network stack. You can find more information on
lwIP <a class="reference external" href="http://www.sics.se/~adam/lwip/">here</a>. In this assignment, as
far as we are concerned, lwIP is a black box that implements a BSD
socket interface and has a packet input port and packet output port.</p>
<p>The network server is actually a combination of four environments:</p>
<ul class="simple">
<li><p>Core network server environment (includes socket call dispatcher and lwIP)</p></li>
<li><p>Input environment</p></li>
<li><p>Output environment</p></li>
<li><p>Timer environment</p></li>
</ul>
<p>The following diagram shows the different environments and their
relationships. The diagram shows the entire system including the device
driver, which will be covered later. In this lab, you will implement the
parts highlighted in green.</p>
<figure class="align-center" id="id3">
<img alt="Network server architecture" src="../_images/ns.png" />
<figcaption>
<p><span class="caption-text">Network server architecture</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="the-core-network-server-environment">
<h3>The Core Network Server Environment<a class="headerlink" href="#the-core-network-server-environment" title="Permalink to this heading">¶</a></h3>
<p>The core network server environment is composed of the socket call
dispatcher and lwIP itself. The socket call dispatcher works exactly
like the file server. User environments use stubs (found in
<code class="docutils literal notranslate"><span class="pre">lib/nsipc.c</span></code>) to send IPC messages to the core network environment.
If you look at <code class="docutils literal notranslate"><span class="pre">lib/nsipc.c</span></code> you will see that we find the core
network server the same way we found the file server: <code class="docutils literal notranslate"><span class="pre">i386_init</span></code>
created the NS environment with <code class="docutils literal notranslate"><span class="pre">NS\_TYPE\_NS</span></code>, so we scan <code class="docutils literal notranslate"><span class="pre">envs</span></code>,
looking for this special environment type. For each user environment
IPC, the dispatcher in the network server calls the appropriate BSD
socket interface function provided by lwIP on behalf of the user.</p>
<p>Regular user environments do not use the <code class="docutils literal notranslate"><span class="pre">nsipc_*</span></code> calls directly.
Instead, they use the functions in <code class="docutils literal notranslate"><span class="pre">lib/sockets.c</span></code>, which provides a
file descriptor-based sockets API. Thus, user environments refer to
sockets via file descriptors, just like how they referred to on-disk
files. A number of operations (<code class="docutils literal notranslate"><span class="pre">connect</span></code>, <code class="docutils literal notranslate"><span class="pre">accept</span></code>, etc.) are
specific to sockets, but <code class="docutils literal notranslate"><span class="pre">read</span></code>, <code class="docutils literal notranslate"><span class="pre">write</span></code>, and <code class="docutils literal notranslate"><span class="pre">close</span></code> go through
the normal file descriptor device-dispatch code in <code class="docutils literal notranslate"><span class="pre">lib/fd.c</span></code>. Much
like how the file server maintained internal unique ID’s for all open
files, lwIP also generates unique ID’s for all open sockets. In both the
file server and the network server, we use information stored in
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Fd</span></code> to map per-environment file descriptors to these unique ID
spaces.</p>
<p>Even though it may seem that the IPC dispatchers of the file server and
network server act the same, there is a key difference. BSD socket calls
like <code class="docutils literal notranslate"><span class="pre">accept</span></code> and <code class="docutils literal notranslate"><span class="pre">recv</span></code> can block indefinitely. If the dispatcher
were to let lwIP execute one of these blocking calls, the dispatcher
would also block and there could only be one outstanding network call at
a time for the whole system. Since this is unacceptable, the network
server uses user-level threading to avoid blocking the entire server
environment. For every incoming IPC message, the dispatcher creates a
thread and processes the request in the newly created thread. If the
thread blocks, then only that thread is put to sleep while other threads
continue to run.</p>
<p>In addition to the core network environment there are three helper
environments. Besides accepting messages from user applications, the
core network environment’s dispatcher also accepts messages from the
input and timer environments.</p>
</section>
<section id="the-output-environment">
<h3>The Output Environment<a class="headerlink" href="#the-output-environment" title="Permalink to this heading">¶</a></h3>
<p>When servicing user environment socket calls, lwIP will generate packets
for the network card to transmit. lwIP will send each packet to be
transmitted to the output helper environment using the <code class="docutils literal notranslate"><span class="pre">NSREQ_OUTPUT</span></code>
IPC message with the packet attached in the page argument of the IPC
message. The output environment is responsible for accepting these
messages and forwarding the packet on to the device driver via the
system call interface that you will soon create.</p>
</section>
<section id="the-input-environment">
<h3>The Input Environment<a class="headerlink" href="#the-input-environment" title="Permalink to this heading">¶</a></h3>
<p>Packets received by the network card need to be injected into lwIP. For
every packet received by the device driver, the input environment pulls
the packet out of kernel space (using kernel system calls that you will
implement) and sends the packet to the core server environment using the
<code class="docutils literal notranslate"><span class="pre">NSREQ_INPUT</span></code> IPC message.</p>
<p>The packet input functionality is separated from the core network
environment because JOS makes it hard to simultaneously accept IPC
messages and poll or wait for a packet from the device driver. We do not
have a <code class="docutils literal notranslate"><span class="pre">select</span></code> system call in JOS that would allow environments to
monitor multiple input sources to identify which input is ready to be
processed.</p>
<p>If you take a look at <code class="docutils literal notranslate"><span class="pre">net/input.c</span></code> and <code class="docutils literal notranslate"><span class="pre">net/output.c</span></code> you will see
that both need to be implemented. This is mainly because the
implementation depends on your system call interface. You will write the
code for the two helper environments after you implement the driver and
system call interface.</p>
</section>
<section id="the-timer-environment">
<h3>The Timer Environment<a class="headerlink" href="#the-timer-environment" title="Permalink to this heading">¶</a></h3>
<p>The timer environment periodically sends messages of type
<code class="docutils literal notranslate"><span class="pre">NSREQ_TIMER</span></code> to the core network server notifying it that a timer has
expired. The timer messages from this thread are used by lwIP to
implement various network timeouts.</p>
</section>
<section id="part-a-initialization-and-transmitting-packets">
<h3>Part A: Initialization and transmitting packets<a class="headerlink" href="#part-a-initialization-and-transmitting-packets" title="Permalink to this heading">¶</a></h3>
<p>Your kernel does not have a notion of time, so we need to add it. There
is currently a clock interrupt that is generated by the hardware every
10ms. On every clock interrupt we can increment a variable to indicate
that time has advanced by 10ms. This is implemented in <code class="docutils literal notranslate"><span class="pre">kern/time.c</span></code>,
but is not yet fully integrated into your kernel.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 1.</strong>
Add a call to <code class="docutils literal notranslate"><span class="pre">time_tick</span></code> for every clock interrupt in
<code class="docutils literal notranslate"><span class="pre">kern/trap.c</span></code>. Implement <code class="docutils literal notranslate"><span class="pre">sys_time_msec</span></code> and add it to <code class="docutils literal notranslate"><span class="pre">syscall</span></code>
in <code class="docutils literal notranslate"><span class="pre">kern/syscall.c</span></code> so that user space has access to the time.</p>
</div>
<p>Use <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">INIT_CFLAGS=-DTEST_NO_NS</span> <span class="pre">run-testtime</span></code> to test your time
code. You should see the environment count down from 5 in 1 second
intervals. The <code class="docutils literal notranslate"><span class="pre">-DTEST_NO_NS</span></code> disables starting the network server
environment because it will panic at this point in the lab.</p>
</section>
</section>
<section id="the-network-interface-card">
<h2>The Network Interface Card<a class="headerlink" href="#the-network-interface-card" title="Permalink to this heading">¶</a></h2>
<p>Writing a driver requires knowing in depth the hardware and the
interface presented to the software. The lab text will provide a
high-level overview of how to interface with the E1000, but you’ll need
to make extensive use of Intel’s manual while writing your driver.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 2.</strong>
Browse Intel’s <a class="reference external" href="../r/hardware/8254x_GBe_SDM.pdf">Software Developer’s
Manual</a> for the E1000.
This manual covers several closely related Ethernet controllers. QEMU
emulates the 82540EM.</p>
</div>
<p>You should skim over chapter 2 now to get a feel for the device. To
write your driver, you’ll need to be familiar with chapters 3 and 14, as
well as 4.1 (though not 4.1’s subsections). You’ll also need to use
chapter 13 as reference. The other chapters mostly cover components of
the E1000 that your driver won’t have to interact with. Don’t worry
about the details right now; just get a feel for how the document is
structured so you can find things later.</p>
<p>While reading the manual, keep in mind that the E1000 is a sophisticated
device with many advanced features. A working E1000 driver only needs a
fraction of the features and interfaces that the NIC provides. Think
carefully about the easiest way to interface with the card. We strongly
recommend that you get a basic driver working before taking advantage of
the advanced features.</p>
<section id="pci-interface">
<h3>PCI Interface<a class="headerlink" href="#pci-interface" title="Permalink to this heading">¶</a></h3>
<p>The E1000 is a PCI device, which means it plugs into the PCI bus on the
motherboard. The PCI bus has address, data, and interrupt lines, and
allows the CPU to communicate with PCI devices and PCI devices to read
and write memory. A PCI device needs to be discovered and initialized
before it can be used. Discovery is the process of walking the PCI bus
looking for attached devices. Initialization is the process of
allocating I/O and memory space as well as negotiating the IRQ line for
the device to use.</p>
<p>We have provided you with PCI code in <code class="docutils literal notranslate"><span class="pre">kern/pci.c</span></code>. To perform PCI
initialization during boot, the PCI code walks the PCI bus looking for
devices. When it finds a device, it reads its vendor ID and device ID
and uses these two values as a key to search the <code class="docutils literal notranslate"><span class="pre">pci_attach_vendor</span></code>
array. The array is composed of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_driver</span></code> entries like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">pci_driver</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">key1</span><span class="p">,</span><span class="w"> </span><span class="n">key2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">attachfn</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pci_func</span><span class="w"> </span><span class="o">*</span><span class="n">pcif</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>If the discovered device’s vendor ID and device ID match an entry in the
array, the PCI code calls that entry’s <code class="docutils literal notranslate"><span class="pre">attachfn</span></code> to perform device
initialization. (Devices can also be identified by class, which is what
the other driver table in <code class="docutils literal notranslate"><span class="pre">kern/pci.c</span></code> is for.)</p>
<p>The attach function is passed a <em>PCI function</em> to initialize. A PCI card
can expose multiple functions, though the E1000 exposes only one. Here
is how we represent a PCI function in JOS:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">pci_func</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">pci_bus</span><span class="w"> </span><span class="o">*</span><span class="n">bus</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dev</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">func</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dev_id</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dev_class</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">reg_base</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">reg_size</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">irq_line</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>The above structure reflects some of the entries found in Table 4-1 of
Section 4.1 of the developer manual. The last three entries of
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_func</span></code> are of particular interest to us, as they record the
negotiated memory, I/O, and interrupt resources for the device. The
<code class="docutils literal notranslate"><span class="pre">reg_base</span></code> and <code class="docutils literal notranslate"><span class="pre">reg_size</span></code> arrays contain information for up to six
Base Address Registers or BARs. <code class="docutils literal notranslate"><span class="pre">reg_base</span></code> stores the base memory
addresses for memory-mapped I/O regions (or base I/O ports for I/O port
resources), <code class="docutils literal notranslate"><span class="pre">reg_size</span></code> contains the size in bytes or number of I/O
ports for the corresponding base values from <code class="docutils literal notranslate"><span class="pre">reg_base</span></code>, and
<code class="docutils literal notranslate"><span class="pre">irq_line</span></code> contains the IRQ line assigned to the device for
interrupts. The specific meanings of the E1000 BARs are given in the
second half of table 4-2.</p>
<p>When the attach function of a device is called, the device has been
found but not yet <em>enabled</em>. This means that the PCI code has not yet
determined the resources allocated to the device, such as address space
and an IRQ line, and, thus, the last three elements of the
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_func</span></code> structure are not yet filled in. The attach function
should call <code class="docutils literal notranslate"><span class="pre">pci_func_enable</span></code>, which will enable the device, negotiate
these resources, and fill in the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_func</span></code>.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 3.</strong>
Implement an attach function to initialize the E1000. Add an
entry to the <code class="docutils literal notranslate"><span class="pre">pci_attach_vendor</span></code> array in <code class="docutils literal notranslate"><span class="pre">kern/pci.c</span></code> to trigger
your function if a matching PCI device is found (be sure to put it
before the <code class="docutils literal notranslate"><span class="pre">{0,</span> <span class="pre">0,</span> <span class="pre">0}</span></code> entry that mark the end of the table). You can
find the vendor ID and device ID of the 82540EM that QEMU emulates in
section 5.2. You should also see these listed when JOS scans the PCI bus
while booting.</p>
</div>
<p>For now, just enable the E1000 device via <code class="docutils literal notranslate"><span class="pre">pci_func_enable</span></code>. We’ll add
more initialization throughout the lab.</p>
<p>We have provided the <code class="docutils literal notranslate"><span class="pre">kern/e1000.c</span></code> and <code class="docutils literal notranslate"><span class="pre">kern/e1000.h</span></code> files for you
so that you do not need to mess with the build system. They are
currently blank; you need to fill them in for this exercise. You may
also need to include the <code class="docutils literal notranslate"><span class="pre">e1000.h</span></code> file in other places in the kernel.</p>
<p>When you boot your kernel, you should see it print that the PCI function
of the E1000 card was enabled. Your code should now pass the
“pci attach” test of <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">grade</span></code>.</p>
</section>
<section id="memory-mapped-i-o">
<h3>Memory-mapped I/O<a class="headerlink" href="#memory-mapped-i-o" title="Permalink to this heading">¶</a></h3>
<p>Software communicates with the E1000 via <em>memory-mapped I/O</em> (MMIO).
You’ve seen this twice before in JOS: both the CGA console and the LAPIC
are devices that you control and query by writing to and reading from
“memory”. But these reads and writes don’t go to DRAM; they go directly
to these devices.</p>
<p><code class="docutils literal notranslate"><span class="pre">pci_func_enable</span></code> negotiates an MMIO region with the E1000 and stores
its base and size in BAR 0 (that is, <code class="docutils literal notranslate"><span class="pre">reg_base[0]</span></code> and
<code class="docutils literal notranslate"><span class="pre">reg_size[0]</span></code>). This is a range of <em>physical memory addresses</em>
assigned to the device, which means you’ll have to do something to
access it via virtual addresses. Since MMIO regions are assigned very
high physical addresses (typically above 3GB), you can’t use <code class="docutils literal notranslate"><span class="pre">KADDR</span></code>
to access it because of JOS’s 256MB limit. Thus, you’ll have to create a
new memory mapping. We’ll use the area above MMIOBASE (your
<code class="docutils literal notranslate"><span class="pre">mmio_map_region</span></code> from lab 4 will make sure we don’t overwrite the
mapping used by the LAPIC). Since PCI device initialization happens
before JOS creates user environments, you can create the mapping in
<code class="docutils literal notranslate"><span class="pre">kern_pgdir</span></code> and it will always be available.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 4.</strong>
In your attach function, create a virtual memory mapping for
the E1000’s BAR 0 by calling <code class="docutils literal notranslate"><span class="pre">mmio_map_region</span></code> (which you wrote in lab
4 to support memory-mapping the LAPIC).</p>
<p>You’ll want to record the location of this mapping in a variable so you
can later access the registers you just mapped. Take a look at the
<code class="docutils literal notranslate"><span class="pre">lapic</span></code> variable in <code class="docutils literal notranslate"><span class="pre">kern/lapic.c</span></code> for an example of one way to do
this. If you do use a pointer to the device register mapping, be sure to
declare it <code class="docutils literal notranslate"><span class="pre">volatile</span></code>; otherwise, the compiler is allowed to cache
values and reorder accesses to this memory.</p>
<p>To test your mapping, try printing out the device status register
(section 13.4.2). This is a 4 byte register that starts at byte 8 of the
register space. You should get <code class="docutils literal notranslate"><span class="pre">0x80080783</span></code>, which indicates a full
duplex link is up at 1000 MB/s, among other things.</p>
</div>
<p>Hint: You’ll need a lot of constants, like the locations of registers
and values of bit masks. Trying to copy these out of the developer’s
manual is error-prone and mistakes can lead to painful debugging
sessions. We recommend instead using QEMU’s
<a class="reference external" href="http://cvs.savannah.gnu.org/viewvc/*checkout*/qemu/hw/e1000_hw.h?root=qemu&amp;content-type=text/plain">e1000_hw.h</a>
header as a guideline. We don’t
recommend copying it in verbatim, because it defines far more than you
actually need and may not define things in the way you need, but it’s a
good starting point.</p>
</section>
<section id="dma">
<h3>DMA<a class="headerlink" href="#dma" title="Permalink to this heading">¶</a></h3>
<p>You could imagine transmitting and receiving packets by writing and
reading from the E1000’s registers, but this would be slow and would
require the E1000 to buffer packet data internally. Instead, the E1000
uses <em>Direct Memory Access</em> or DMA to read and write packet data
directly from memory without involving the CPU. The driver is
responsible for allocating memory for the transmit and receive queues,
setting up DMA descriptors, and configuring the E1000 with the location
of these queues, but everything after that is asynchronous. To transmit
a packet, the driver copies it into the next DMA descriptor in the
transmit queue and informs the E1000 that another packet is available;
the E1000 will copy the data out of the descriptor when there is time to
send the packet. Likewise, when the E1000 receives a packet, it copies
it into the next DMA descriptor in the receive queue, which the driver
can read from at its next opportunity.</p>
<p>The receive and transmit queues are very similar at a high level. Both
consist of a sequence of <em>descriptors</em>. While the exact structure of
these descriptors varies, each descriptor contains some flags and the
physical address of a buffer containing packet data (either packet data
for the card to send, or a buffer allocated by the OS for the card to
write a received packet to).</p>
<p>The queues are implemented as circular arrays, meaning that when the
card or the driver reach the end of the array, it wraps back around to
the beginning. Both have a <em>head pointer</em> and a <em>tail pointer</em> and the
contents of the queue are the descriptors between these two pointers.
The hardware always consumes descriptors from the head and moves the
head pointer, while the driver always add descriptors to the tail and
moves the tail pointer. The descriptors in the transmit queue represent
packets waiting to be sent (hence, in the steady state, the transmit
queue is empty). For the receive queue, the descriptors in the queue are
free descriptors that the card can receive packets into (hence, in the
steady state, the receive queue consists of all available receive
descriptors).</p>
<p>The pointers to these arrays as well as the addresses of the packet
buffers in the descriptors must all be <em>physical addresses</em> because
hardware performs DMA directly to and from physical RAM without going
through the MMU.</p>
</section>
</section>
<section id="transmitting-packets">
<h2>Transmitting Packets<a class="headerlink" href="#transmitting-packets" title="Permalink to this heading">¶</a></h2>
<p>The transmit and receive functions of the E1000 are basically
independent of each other, so we can work on one at a time. We’ll attack
transmitting packets first simply because we can’t test receive without
transmitting an “I’m here!” packet first.</p>
<p>First, you’ll have to initialize the card to transmit, following the
steps described in section 14.5 (you don’t have to worry about the
subsections). The first step of transmit initialization is setting up
the transmit queue. The precise structure of the queue is described in
section 3.4 and the structure of the descriptors is described in section
3.3.3. We won’t be using the TCP offload features of the E1000, so you
can focus on the “legacy transmit descriptor format.” You should read
those sections now and familiarize yourself with these structures.</p>
<section id="c-structures">
<h3>C Structures<a class="headerlink" href="#c-structures" title="Permalink to this heading">¶</a></h3>
<p>You’ll find it convenient to use C <code class="docutils literal notranslate"><span class="pre">struct``s</span> <span class="pre">to</span> <span class="pre">describe</span> <span class="pre">the</span> <span class="pre">E1000's</span>
<span class="pre">structures.</span> <span class="pre">As</span> <span class="pre">you've</span> <span class="pre">seen</span> <span class="pre">with</span> <span class="pre">structures</span> <span class="pre">like</span> <span class="pre">the</span>
<span class="pre">``struct</span> <span class="pre">Trapframe</span></code>, C <a href="#id1"><span class="problematic" id="id2">``</span></a>struct``s let you precisely layout data in
memory. C can insert padding between fields, but the E1000’s structures
are laid out such that this shouldn’t be a problem. If you do encounter
field alignment problems, look into GCC’s “packed” attribute.</p>
<p>As an example, consider the legacy transmit descriptor given in table
3-8 of the manual and reproduced here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">63</span>            <span class="mi">48</span> <span class="mi">47</span>   <span class="mi">40</span> <span class="mi">39</span>   <span class="mi">32</span> <span class="mi">31</span>   <span class="mi">24</span> <span class="mi">23</span>   <span class="mi">16</span> <span class="mi">15</span>             <span class="mi">0</span>
<span class="o">+---------------------------------------------------------------+</span>
<span class="o">|</span>                         <span class="n">Buffer</span> <span class="n">address</span>                        <span class="o">|</span>
<span class="o">+---------------+-------+-------+-------+-------+---------------+</span>
<span class="o">|</span>    <span class="n">Special</span>    <span class="o">|</span>  <span class="n">CSS</span>  <span class="o">|</span> <span class="n">Status</span><span class="o">|</span>  <span class="n">Cmd</span>  <span class="o">|</span>  <span class="n">CSO</span>  <span class="o">|</span>    <span class="n">Length</span>     <span class="o">|</span>
<span class="o">+---------------+-------+-------+-------+-------+---------------+</span>
</pre></div>
</div>
<p>The first byte of the structure starts at the top right, so to convert
this into a C struct, read from right to left, top to bottom. If you
squint at it right, you’ll see that all of the fields even fit nicely
into a standard-size types:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">tx_desc</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">cso</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">cmd</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">status</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">css</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">special</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Your driver will have to reserve memory for the transmit descriptor
array and the packet buffers pointed to by the transmit descriptors.
There are several ways to do this, ranging from dynamically allocating
pages to simply declaring them in global variables. Whatever you choose,
keep in mind that the E1000 accesses physical memory directly, which
means any buffer it accesses must be contiguous in physical memory.</p>
<p>There are also multiple ways to handle the packet buffers. The simplest,
which we recommend starting with, is to reserve space for a packet
buffer for each descriptor during driver initialization and simply copy
packet data into and out of these pre-allocated buffers. The maximum
size of an Ethernet packet is 1518 bytes, which bounds how big these
buffers need to be. More sophisticated drivers could dynamically
allocate packet buffers (e.g., to reduce memory overhead when network
usage is low) or even pass buffers directly provided by user space (a
technique known as “zero copy”), but it’s good to start simple.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 5.</strong>
Perform the initialization steps described in section 14.5
(but not its subsections). Use section 13 as a reference for the
registers the initialization process refers to and sections 3.3.3 and
3.4 for reference to the transmit descriptors and transmit descriptor
array.</p>
<p>Be mindful of the alignment requirements on the transmit descriptor
array and the restrictions on length of this array. Since <code class="docutils literal notranslate"><span class="pre">TDLEN</span></code> must be
128-byte aligned and each transmit descriptor is 16 bytes, your transmit
descriptor array will need some multiple of 8 transmit descriptors.
However, don’t use more than 64 descriptors or our tests won’t be able
to test transmit ring overflow.</p>
<p>For the <code class="docutils literal notranslate"><span class="pre">TCTL.COLD</span></code>, you can assume full-duplex operation. For <code class="docutils literal notranslate"><span class="pre">TIPG</span></code>, refer
to the default values described in table 13-77 of section 13.4.34 for
the IEEE 802.3 standard IPG (don’t use the values in the table in
section 14.5).</p>
</div>
<p>Try running <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">E1000_DEBUG=TXERR,TX</span> <span class="pre">qemu</span></code>. If you are using the course
qemu, you should see an “e1000: tx disabled” message when you set the
<code class="docutils literal notranslate"><span class="pre">TDT</span></code> register (since this happens before you set <code class="docutils literal notranslate"><span class="pre">TCTL.EN</span></code>) and no further
“e1000” messages.</p>
<p>Now that transmit is initialized, you’ll have to write the code to
transmit a packet and make it accessible to user space via a system
call. To transmit a packet, you have to add it to the tail of the
transmit queue, which means copying the packet data into the next packet
buffer and then updating the <code class="docutils literal notranslate"><span class="pre">TDT</span></code> (transmit descriptor tail) register to
inform the card that there’s another packet in the transmit queue. (Note
that <code class="docutils literal notranslate"><span class="pre">TDT</span></code> is an <em>index</em> into the transmit descriptor array, not a byte
offset; the documentation isn’t very clear about this.)</p>
<p>However, the transmit queue is only so big. What happens if the card has
fallen behind transmitting packets and the transmit queue is full? In
order to detect this condition, you’ll need some feedback from the
E1000. Unfortunately, you can’t just use the <code class="docutils literal notranslate"><span class="pre">TDH</span></code> (transmit descriptor
head) register; the documentation explicitly states that reading this
register from software is unreliable. However, if you set the <code class="docutils literal notranslate"><span class="pre">RS</span></code> bit in
the command field of a transmit descriptor, then, when the card has
transmitted the packet in that descriptor, the card will set the <code class="docutils literal notranslate"><span class="pre">DD</span></code> bit
in the status field of the descriptor. If a descriptor’s <code class="docutils literal notranslate"><span class="pre">DD</span></code> bit is set,
you know it’s safe to recycle that descriptor and use it to transmit
another packet.</p>
<p>What if the user calls your transmit system call, but the <code class="docutils literal notranslate"><span class="pre">DD</span></code> bit of the
next descriptor isn’t set, indicating that the transmit queue is full?
You’ll have to decide what to do in this situation. You could simply
drop the packet. Network protocols are resilient to this, but if you
drop a large burst of packets, the protocol may not recover. You could
tell the user environment that it has to retry, much like you did for
<code class="docutils literal notranslate"><span class="pre">sys_ipc_try_send</span></code>. This has the advantage of pushing back on the
environment generating the data. You could spin in the driver until a
transmit descriptor frees up, but this may introduce serious performance
problems since the JOS kernel isn’t designed to block. Finally, you
could put the transmitting environment to sleep and request that the
card send an interrupt when transmit descriptors free up. We recommend
that you start with whatever you think is simplest.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 6.</strong>
Write a function to transmit a packet by checking that the
next descriptor is free, copying the packet data into the next
descriptor, and updating <code class="docutils literal notranslate"><span class="pre">TDT</span></code>. Make sure you handle the transmit queue
being full.</p>
</div>
<p>Now would be a good time to test your packet transmit code. Try
transmitting just a few packets by directly calling your transmit
function from the kernel. You don’t have to create packets that conform
to any particular network protocol in order to test this. Run
<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">E1000_DEBUG=TXERR,TX</span> <span class="pre">qemu</span></code> to run your test. You should see something
like</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>e1000: index <span class="m">0</span>: 0x271f00 : 9000002a <span class="m">0</span>
...
</pre></div>
</div>
<p>as you transmit packets. Each line gives the index in the transmit
array, the buffer address of that transmit descriptor, the
cmd/CSO/length fields, and the special/CSS/status fields. If QEMU
doesn’t print the values you expected from your transmit descriptor,
check that you’re filling in the right descriptor and that you
configured <code class="docutils literal notranslate"><span class="pre">TDBAL</span></code> and <code class="docutils literal notranslate"><span class="pre">TDBAH</span></code> correctly. If you get “e1000: TDH wraparound
&#64;0, TDT x, TDLEN y” messages, that means the E1000 ran all the way
through the transmit queue without stopping (if QEMU didn’t check this,
it would enter an infinite loop), which probably means you aren’t
manipulating <code class="docutils literal notranslate"><span class="pre">TDT</span></code> correctly. If you get lots of “e1000: tx disabled”
messages, then you didn’t set the transmit control register right.</p>
<p>Once QEMU runs, you can then run <code class="docutils literal notranslate"><span class="pre">tcpdump</span> <span class="pre">-XXnr</span> <span class="pre">qemu.pcap</span></code> to see the
packet data that you transmitted. If you saw the expected “e1000: index”
messages from QEMU, but your packet capture is empty, double check that
you filled in every necessary field and bit in your transmit descriptors
(the E1000 probably went through your transmit descriptors, but didn’t
think it had to send anything).</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 7.</strong>
Add a system call that lets you transmit packets from user
space. The exact interface is up to you. Don’t forget to check any
pointers passed to the kernel from user space.</p>
</div>
</section>
<section id="transmitting-packets-network-server">
<h3>Transmitting Packets: Network Server<a class="headerlink" href="#transmitting-packets-network-server" title="Permalink to this heading">¶</a></h3>
<p>Now that you have a system call interface to the transmit side of your
device driver, it’s time to send packets. The output helper
environment’s goal is to do the following in a loop: accept
<code class="docutils literal notranslate"><span class="pre">NSREQ_OUTPUT</span></code> IPC messages from the core network server and send the
packets accompanying these IPC message to the network device driver
using the system call you added above. The <code class="docutils literal notranslate"><span class="pre">NSREQ_OUTPUT</span></code> IPC’s are
sent by the <code class="docutils literal notranslate"><span class="pre">low_level_output</span></code> function in <code class="docutils literal notranslate"><span class="pre">net/lwip/jos/jif/jif.c</span></code>,
which glues the lwIP stack to JOS’s network system. Each IPC will
include a page consisting of a <code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">Nsipc</span></code> with the packet in its
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">jif_pkt</span> <span class="pre">pkt</span></code> field (see <code class="docutils literal notranslate"><span class="pre">inc/ns.h</span></code>). <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">jif_pkt</span></code>
looks like</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">jif_pkt</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">jp_len</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">jp_data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">jp_len</span></code> represents the length of the packet. All subsequent bytes on
the IPC page are dedicated to the packet contents. Using a zero-length
array like <code class="docutils literal notranslate"><span class="pre">jp_data</span></code> at the end of a struct is a common C trick (some
would say abomination) for representing buffers without pre-determined
lengths. Since C doesn’t do array bounds checking, as long as you ensure
there’s enough unused memory following the struct, you can use
<code class="docutils literal notranslate"><span class="pre">jp_data</span></code> as if it were an array of any size.</p>
<p>Be aware of the interaction between the device driver, the output
environment and the core network server when there is no more space in
the device driver’s transmit queue. The core network server sends
packets to the output environment using IPC. If the output environment
is suspended due to a send packet system call because the driver has no
more buffer space for new packets, the core network server will block
waiting for the output server to accept the IPC call.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 8.</strong>
Implement <code class="docutils literal notranslate"><span class="pre">net/output.c</span></code>.</p>
</div>
<p>You can use <code class="docutils literal notranslate"><span class="pre">net/testoutput.c</span></code> to test your output code without
involving the whole network server. Try running
<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">E1000_DEBUG=TXERR,TX</span> <span class="pre">run-net_testoutput</span></code>. You should see something like</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>Transmitting packet <span class="m">0</span>
e1000: index <span class="m">0</span>: 0x271f00 : <span class="m">9000009</span> <span class="m">0</span>
Transmitting packet <span class="m">1</span>
e1000: index <span class="m">1</span>: 0x2724ee : <span class="m">9000009</span> <span class="m">0</span>
...
</pre></div>
</div>
<p>and <code class="docutils literal notranslate"><span class="pre">tcpdump</span> <span class="pre">-XXnr</span> <span class="pre">qemu.pcap</span></code> should output</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>reading from file qemu.pcap, link-type EN10MB <span class="o">(</span>Ethernet<span class="o">)</span>
-5:00:00.600186 <span class="o">[</span><span class="p">|</span>ether<span class="o">]</span>
    0x0000:  <span class="m">5061</span> 636b <span class="m">6574</span> <span class="m">2030</span> <span class="m">30</span>                   Packet.00
-5:00:00.610080 <span class="o">[</span><span class="p">|</span>ether<span class="o">]</span>
    0x0000:  <span class="m">5061</span> 636b <span class="m">6574</span> <span class="m">2030</span> <span class="m">31</span>                   Packet.01
...
</pre></div>
</div>
<p>To test with a larger packet count, try
<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">E1000_DEBUG=TXERR,TXNET_CFLAGS=-DTESTOUTPUT_COUNT=100</span> <span class="pre">run-net_testoutput</span></code>. If this
overflows your transmit ring, double check that you’re handling the <code class="docutils literal notranslate"><span class="pre">DD</span></code>
status bit correctly and that you’ve told the hardware to set the <code class="docutils literal notranslate"><span class="pre">DD</span></code>
status bit (using the <code class="docutils literal notranslate"><span class="pre">RS</span></code> command bit).</p>
<p>Your code should pass the <code class="docutils literal notranslate"><span class="pre">testoutput</span></code> tests of make grade.</p>
<div class="admonition-question admonition">
<p class="admonition-title">Question</p>
<p><strong>Question</strong>
1. How did you structure your transmit implementation? In particular,
what do you do if the transmit ring is full?</p>
</div>
</section>
<section id="part-b-receiving-packets-and-the-web-server">
<h3>Part B: Receiving packets and the web server<a class="headerlink" href="#part-b-receiving-packets-and-the-web-server" title="Permalink to this heading">¶</a></h3>
</section>
<section id="receiving-packets">
<h3>Receiving Packets<a class="headerlink" href="#receiving-packets" title="Permalink to this heading">¶</a></h3>
<p>Just like you did for transmitting packets, you’ll have to configure the
E1000 to receive packets and provide a receive descriptor queue and
receive descriptors. Section 3.2 describes how packet reception works,
including the receive queue structure and receive descriptors, and the
initialization process is detailed in section 14.4.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 9.</strong>
Read section 3.2. You can ignore anything about interrupts
and checksum offloading (you can return to these sections if you decide
to use these features later), and you don’t have to be concerned with
the details of thresholds and how the card’s internal caches work.</p>
</div>
<p>The receive queue is very similar to the transmit queue, except that it
consists of empty packet buffers waiting to be filled with incoming
packets. Hence, when the network is idle, the transmit queue is empty
(because all packets have been sent), but the receive queue is full (of
empty packet buffers).</p>
<p>When the E1000 receives a packet, it first checks if it matches the
card’s configured filters (for example, to see if the packet is
addressed to this E1000’s MAC address) and ignores the packet if it
doesn’t match any filters. Otherwise, the E1000 tries to retrieve the
next receive descriptor from the head of the receive queue. If the head
(<code class="docutils literal notranslate"><span class="pre">RDH</span></code>) has caught up with the tail (<code class="docutils literal notranslate"><span class="pre">RDT</span></code>), then the receive queue is out
of free descriptors, so the card drops the packet. If there is a free
receive descriptor, it copies the packet data into the buffer pointed to
by the descriptor, sets the descriptor’s <code class="docutils literal notranslate"><span class="pre">DD</span></code> (Descriptor Done) and <code class="docutils literal notranslate"><span class="pre">EOP</span></code>
(End of Packet) status bits, and increments the <code class="docutils literal notranslate"><span class="pre">RDH</span></code>.</p>
<p>If the E1000 receives a packet that is larger than the packet buffer in
one receive descriptor, it will retrieve as many descriptors as
necessary from the receive queue to store the entire contents of the
packet. To indicate that this has happened, it will set the <code class="docutils literal notranslate"><span class="pre">DD</span></code> status
bit on all of these descriptors, but only set the <code class="docutils literal notranslate"><span class="pre">EOP</span></code> status bit on the
last of these descriptors. You can either deal with this possibility in
your driver, or simply configure the card to not accept “long packets”
(also known as <em>jumbo frames</em>) and make sure your receive buffers are
large enough to store the largest possible standard Ethernet packet
(1518 bytes).</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 10.</strong>
Set up the receive queue and configure the E1000 by
following the process in section 14.4. You don’t have to support “long
packets” or multicast. For now, don’t configure the card to use
interrupts; you can change that later if you decide to use receive
interrupts. Also, configure the E1000 to strip the Ethernet CRC, since
the grade script expects it to be stripped.</p>
<p>By default, the card will filter out <em>all</em> packets. You have to
configure the Receive Address Registers (<code class="docutils literal notranslate"><span class="pre">RAL</span></code> and <code class="docutils literal notranslate"><span class="pre">RAH</span></code>) with the card’s
own MAC address in order to accept packets addressed to that card. You
can simply hard-code QEMU’s default MAC address of 52:54:00:12:34:56 (we
already hard-code this in lwIP, so doing it here too doesn’t make things
any worse). Be very careful with the byte order; MAC addresses are
written from lowest-order byte to highest-order byte, so 52:54:00:12 are
the low-order 32 bits of the MAC address and 34:56 are the high-order 16
bits.</p>
<p>The E1000 only supports a specific set of receive buffer sizes (given in
the description of RCTL.BSIZE in 13.4.22). If you make your receive
packet buffers large enough and disable long packets, you won’t have to
worry about packets spanning multiple receive buffers. Also, remember
that, just like for transmit, the receive queue and the packet buffers
must be contiguous in physical memory.</p>
<p>You should use at least 128 receive descriptors.</p>
</div>
<p>You can do a basic test of receive functionality now, even without
writing the code to receive packets. Run
<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">E1000_DEBUG=TX,TXERR,RX,RXERR,RXFILTER</span> <span class="pre">run-net_testinput</span></code>.
<code class="docutils literal notranslate"><span class="pre">testinput</span></code> will transmit an ARP (Address Resolution Protocol)
announcement packet (using your packet transmitting system call), which
QEMU will automatically reply to. Even though your driver can’t receive
this reply yet, you should see a “e1000: unicast match[0]:
52:54:00:12:34:56” message, indicating that a packet was received by the
E1000 and matched the configured receive filter. If you see a “e1000:
unicast mismatch: 52:54:00:12:34:56” message instead, the E1000 filtered
out the packet, which means you probably didn’t configure RAL and RAH
correctly. Make sure you got the byte ordering right and didn’t forget
to set the “Address Valid” bit in RAH. If you don’t get any “e1000”
messages, you probably didn’t enable receive correctly.</p>
<p>Now you’re ready to implement receiving packets. To receive a packet,
your driver will have to keep track of which descriptor it expects to
hold the next received packet (hint: depending on your design, there’s
probably already be a register in the E1000 keeping track of this).
Similar to transmit, the documentation states that the <code class="docutils literal notranslate"><span class="pre">RDH</span></code> register
cannot be reliably read from software, so in order to determine if a
packet has been delivered to this descriptor’s packet buffer, you’ll
have to read the <code class="docutils literal notranslate"><span class="pre">DD</span></code> status bit in the descriptor. If the <code class="docutils literal notranslate"><span class="pre">DD</span></code> bit is set,
you can copy the packet data out of that descriptor’s packet buffer and
then tell the card that the descriptor is free by updating the queue’s
tail index, <code class="docutils literal notranslate"><span class="pre">RDT</span></code>.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">DD</span></code> bit isn’t set, then no packet has been received. This is the
receive-side equivalent of when the transmit queue was full, and there
are several things you can do in this situation. You can simply return a
“try again” error and require the caller to retry. While this approach
works well for full transmit queues because that’s a transient
condition, it is less justifiable for empty receive queues because the
receive queue may remain empty for long stretches of time. A second
approach is to suspend the calling environment until there are packets
in the receive queue to process. This tactic is very similar to
<code class="docutils literal notranslate"><span class="pre">sys_ipc_recv</span></code>. Just like in the IPC case, since we have only one
kernel stack per CPU, as soon as we leave the kernel the state on the
stack will be lost. We need to set a flag indicating that an environment
has been suspended by receive queue underflow and record the system call
arguments. The drawback of this approach is complexity: the E1000 must
be instructed to generate receive interrupts and the driver must handle
them in order to resume the environment blocked waiting for a packet.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 11.</strong>
Write a function to receive a packet from the E1000 and
expose it to user space by adding a system call. Make sure you handle
the receive queue being empty.</p>
<p>If you decide to use interrupts to detect when packets are received,
you’ll need to write code to handle these interrupts. If you do use
interrupts, note that, once an interrupt is asserted, it will remain
asserted until the driver clears the interrupt. In your interrupt
handler make sure to clear the interrupt handled as soon as you handle
it. If you don’t, after returning from your interrupt handler, the CPU
will jump back into it again. In addition to clearing the interrupts on
the E1000 card, interrupts also need to be cleared on the LAPIC. Use
<code class="docutils literal notranslate"><span class="pre">lapic_eoi</span></code> to do so.</p>
</div>
</section>
<section id="receiving-packets-network-server">
<h3>Receiving Packets: Network Server<a class="headerlink" href="#receiving-packets-network-server" title="Permalink to this heading">¶</a></h3>
<p>In the network server input environment, you will need to use your new
receive system call to receive packets and pass them to the core network
server environment using the <code class="docutils literal notranslate"><span class="pre">NSREQ_INPUT</span></code> IPC message. These IPC
input message should have a page attached with a <code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">Nsipc</span></code> with
its <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">jif_pkt</span> <span class="pre">pkt</span></code> field filled in with the packet received from
the network.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 12.</strong>
Implement <code class="docutils literal notranslate"><span class="pre">net/input.c</span></code>.</p>
</div>
<p>Run <code class="docutils literal notranslate"><span class="pre">testinput</span></code> again with
<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">E1000_DEBUG=TX,TXERR,RX,RXERR,RXFILTER</span> <span class="pre">run-net_testinput</span></code>.
You should see</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>Sending ARP announcement...
Waiting <span class="k">for</span> packets...
e1000: index <span class="m">0</span>: 0x26dea0 : 900002a <span class="m">0</span>
e1000: unicast match<span class="o">[</span><span class="m">0</span><span class="o">]</span>: <span class="m">52</span>:54:00:12:34:56
input: <span class="m">0000</span>   <span class="m">5254</span> <span class="m">0012</span> <span class="m">3456</span> <span class="m">5255</span>  0a00 <span class="m">0202</span> <span class="m">0806</span> <span class="m">0001</span>
input: <span class="m">0010</span>   <span class="m">0800</span> <span class="m">0604</span> <span class="m">0002</span> <span class="m">5255</span>  0a00 <span class="m">0202</span> 0a00 <span class="m">0202</span>
input: <span class="m">0020</span>   <span class="m">5254</span> <span class="m">0012</span> <span class="m">3456</span> 0a00  020f <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>
input: <span class="m">0030</span>   <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>  <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span> <span class="m">0000</span>
</pre></div>
</div>
<p>The lines beginning with “input:” are a hexdump of QEMU’s ARP reply.</p>
<p>Your code should pass the <code class="docutils literal notranslate"><span class="pre">testinput</span></code> tests of <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">grade</span></code>. Note that
there’s no way to test packet receiving without sending at least one ARP
packet to inform QEMU of JOS’ IP address, so bugs in your transmitting
code can cause this test to fail.</p>
<p>To more thoroughly test your networking code, we have provided a daemon
called <code class="docutils literal notranslate"><span class="pre">echosrv</span></code> that sets up an echo server running on port 7 that
will echo back anything sent over a TCP connection. Use
<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">E1000_DEBUG=TX,TXERR,RX,RXERR,RXFILTER</span> <span class="pre">run-echosrv</span></code>
to start the echo
server in one terminal and <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">nc-7</span></code> in another to connect to it. Every
line you type should be echoed back by the server. Every time the
emulated E1000 receives a packet, QEMU should print something like the
following to the console:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>e1000: unicast match<span class="o">[</span><span class="m">0</span><span class="o">]</span>: <span class="m">52</span>:54:00:12:34:56
e1000: index <span class="m">2</span>: 0x26ea7c : <span class="m">9000036</span> <span class="m">0</span>
e1000: index <span class="m">3</span>: 0x26f06a : <span class="m">9000039</span> <span class="m">0</span>
e1000: unicast match<span class="o">[</span><span class="m">0</span><span class="o">]</span>: <span class="m">52</span>:54:00:12:34:56
</pre></div>
</div>
<p>At this point, you should also be able to pass the <code class="docutils literal notranslate"><span class="pre">echosrv</span></code> test.</p>
<div class="admonition-question admonition">
<p class="admonition-title">Question</p>
<p><strong>Question</strong>
2. How did you structure your receive implementation? In particular,
what do you do if the receive queue is empty and a user environment
requests the next incoming packet?</p>
</div>
<div class="admonition-challenge admonition">
<p class="admonition-title">Challenge</p>
<p><strong>Challenge!</strong>
Read about the EEPROM in the developer’s manual and write the
code to load the E1000’s MAC address out of the EEPROM. Currently,
QEMU’s default MAC address is hard-coded into both your receive
initialization and lwIP. Fix your initialization to use the MAC address
you read from the EEPROM, add a system call to pass the MAC address to
lwIP, and modify lwIP to the MAC address read from the card. Test your
change by configuring QEMU to use a different MAC address.</p>
</div>
<div class="admonition-challenge admonition">
<p class="admonition-title">Challenge</p>
<p><strong>Challenge!</strong>
Modify your E1000 driver to be “zero copy.” Currently, packet
data has to be copied from user-space buffers to transmit packet buffers
and from receive packet buffers back to user-space buffers. A zero copy
driver avoids this by having user space and the E1000 share packet
buffer memory directly. There are many different approaches to this,
including mapping the kernel-allocated structures into user space or
passing user-provided buffers directly to the E1000. Regardless of your
approach, be careful how you reuse buffers so that you don’t introduce
races between user-space code and the E1000.</p>
</div>
<div class="admonition-challenge admonition">
<p class="admonition-title">Challenge</p>
<p><strong>Challenge!</strong>
Take the zero copy concept all the way into lwIP.</p>
<p>A typical packet is composed of many headers. The user sends data to be
transmitted to lwIP in one buffer. The TCP layer wants to add a TCP
header, the IP layer an IP header and the MAC layer an Ethernet header.
Even though there are many parts to a packet, right now the parts need
to be joined together so that the device driver can send the final
packet.</p>
<p>The E1000’s transmit descriptor design is well-suited to collecting
pieces of a packet scattered throughout memory, like the packet
fragments created inside lwIP. If you enqueue multiple transmit
descriptors, but only set the EOP command bit on the last one, then the
E1000 will internally concatenate the packet buffers from these
descriptors and only transmit the concatenated buffer when it reaches
the EOP-marked descriptor. As a result, the individual packet pieces
never need to be joined together in memory.</p>
<p>Change your driver to be able to send packets composed of many buffers
without copying and modify lwIP to avoid merging the packet pieces as it
does right now.</p>
</div>
<div class="admonition-challenge admonition">
<p class="admonition-title">Challenge</p>
<p><strong>Challenge!</strong>
Augment your system call interface to service more than one
user environment. This will prove useful if there are multiple network
stacks (and multiple network servers) each with their own IP address
running in user mode. The receive system call will need to decide to
which environment it needs to forward each incoming packet.</p>
<p>Note that the current interface cannot tell the difference between two
packets and if multiple environments call the packet receive system
call, each respective environment will get a subset of the incoming
packets and that subset may include packets that are not destined to the
calling environment.</p>
<p>Sections 2.2 and 3 in
<a class="reference external" href="http://pdos.csail.mit.edu/papers/exo:tocs.pdf">this</a> Exokernel paper
have an in-depth explanation of the problem and a method of addressing
it in a kernel like JOS. Use the paper to help you get a grip on the
problem, chances are you do not need a solution as complex as presented
in the paper.</p>
</div>
</section>
<section id="the-web-server">
<h3>The Web Server<a class="headerlink" href="#the-web-server" title="Permalink to this heading">¶</a></h3>
<p>A web server in its simplest form sends the contents of a file to the
requesting client. We have provided skeleton code for a very simple web
server in <code class="docutils literal notranslate"><span class="pre">user/httpd.c</span></code>. The skeleton code deals with incoming
connections and parses the headers.</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p><strong>Exercise 13.</strong>
The web server is missing the code that deals with sending
the contents of a file back to the client. Finish the web server by
implementing <code class="docutils literal notranslate"><span class="pre">send_file</span></code> and <code class="docutils literal notranslate"><span class="pre">send_data</span></code>.</p>
</div>
<p>Once you’ve finished the web server, point your favorite browser at
<code class="docutils literal notranslate"><span class="pre">http://*host*:*port*/index.html</span></code>, where <em>host</em> is the name of the
computer running QEMU. You should see a web page served by the
HTTP server running inside JOS.</p>
<p>At this point, you should score 105/105 on make grade.</p>
<div class="admonition-challenge admonition">
<p class="admonition-title">Challenge</p>
<p><strong>Challenge!</strong>
Add a simple chat server to JOS, where multiple people can
connect to the server and anything that any user types is transmitted to
the other users. To do this, you will have to find a way to communicate
with multiple sockets at once <em>and</em> to send and receive on the same
socket at the same time. There are multiple ways to go about this. lwIP
provides a <code class="docutils literal notranslate"><span class="pre">MSG_DONTWAIT</span></code> flag for recv (see <code class="docutils literal notranslate"><span class="pre">lwip_recvfrom</span></code> in
<code class="docutils literal notranslate"><span class="pre">net/lwip/api/sockets.c</span></code>), so you could constantly loop through all
open sockets, polling them for data. Note that, while <code class="docutils literal notranslate"><span class="pre">recv</span></code> flags are
supported by the network server IPC, they aren’t accessible via the
regular <code class="docutils literal notranslate"><span class="pre">read</span></code> function, so you’ll need a way to pass the flags. A
more efficient approach is to start one or more environments for each
connection and to use IPC to coordinate them. Conveniently, the lwIP
socket ID found in the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Fd</span></code> for a socket is global (not
per-environment), so, for example, the child of a <code class="docutils literal notranslate"><span class="pre">fork</span></code> inherits its
parents sockets. Or, an environment can even send on another
environment’s socket simply by constructing an Fd containing the right
socket ID.</p>
</div>
<div class="admonition-question admonition">
<p class="admonition-title">Question</p>
<p><strong>Question</strong>
3. What does the web page served by JOS’s web server say?
4. How long approximately did it take you to do this lab?</p>
</div>
<p><strong>This completes the lab.</strong> As usual, don’t forget to run <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">grade</span></code> and
to write up your answers and a description of your challenge exercise
solution. Before handing in, use git status and git diff to examine your
changes and don’t forget to <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">add</span> <span class="pre">answers-lab6.txt</span></code>. When you’re ready,
commit your changes with <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">commit</span> <span class="pre">-am</span> <span class="pre">'my</span> <span class="pre">solutions</span> <span class="pre">to</span> <span class="pre">lab</span> <span class="pre">6'</span></code>, then
tag and push to GitHub.</p>
<script src="../_static/disqus/disqus.js"></script>
<link rel="stylesheet" type="text/css" href="../_static/disqus/disqus.css" />

<script>
  disqus_shortname = 'gatechcs3210staff';
  $(document).ready(function() {
    $("p").inlineDisqussions();
  });
</script></section>
</section>
</section>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../proj.html" class="btn btn-neutral float-right" title="Final Project">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="lab5.html" class="btn btn-neutral" title="Lab 5: File system, Spawn and Shell"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
      Last updated on Jul 02, 2022.
    </p>
  </div>

</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

<script src="../_static/email.js"></script>
<script src="../_static/custom.js"></script>

</body>
</html>